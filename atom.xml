<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生信拾光</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-02-03T08:32:23.841Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>六六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>220203|文献摘要</title>
    <link href="http://yoursite.com/2022/02/03/d7478ebb.html"/>
    <id>http://yoursite.com/2022/02/03/d7478ebb.html</id>
    <published>2022-02-03T07:37:56.243Z</published>
    <updated>2022-02-03T08:32:23.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nat-M-L-将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制"><a href="#Nat-M-L-将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制" class="headerlink" title="Nat. M.L. | 将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制"></a>Nat. M.L. | 将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制</h2><p>题目：Integration of multiomics data with graph convolutional networks to identify new cancer genes and their associated molecular mechanisms</p><p>杂志：Nature Machine Intelligence</p><p>IF: 15</p><p>时间：12 April 2021</p><p>链接：<a href="https://www.nature.com/articles/s42256-021-00325-y" target="_blank" rel="noopener">https://www.nature.com/articles/s42256-021-00325-y</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>随着可用的高通量分子数据的增加，也为识别癌症基因带来了计算上的挑战。遗传和非遗传原因都有可能造成肿瘤的发生，这就需要开发预测模型来有效地整合不同的数据模式，同时具有可解释性。我们介绍了<strong>EMOGI</strong>，这是一种基于图卷积网络的可解释的机器学习方法，其通过结合多组学的泛癌症数据来预测癌症基因，如突变、拷贝数变化、DNA甲基化和基因表达，蛋白质-蛋白质相互作用(PPI) 网络等。在不同的PPI网络和数据集中，EMOGI总体来说比其他方法更准确。我们使用分层相关性传播，根据基因的分类是由相互作用组还是由任何一个全向性水平驱动，对基因进行分层，并确定PPI网络的重要模块。我们提出了165个新的癌症基因，这些基因不一定有反复的改变，但与已知的癌症基因有相互作用。而且我们发现，这些基因与功能缺失筛查中的基本基因相对应。我们相信，我们的方法可以为精准肿瘤学开辟新的途径，并可应用于预测癌症的生物标志物。</p><p><img src="/2022/02/03/d7478ebb/image-20220203092107638.png" alt="image-20220203092107638" style="zoom:50%;"></p><blockquote><p>EMOGI框架的示意图。<strong>a, 数据收集和串联</strong>。计算16个TCGA肿瘤类型的所有基因的平均突变率、CNAs、DNA甲基化和基因表达变化，并在一个早期整合方案中进行连接。然后将得到的特征矩阵与PPI网络和一小部分高置信度的癌症/非癌症基因相结合，形成一个网络，其中节点对应于基因，边对应于它们之间已知的相互作用。每个节点/基因都有一个多维的特征向量（b，输入层）。</p><p><strong>b</strong>，在EMOGI模型训练期间，特征通过连续的图卷积层进行转化（见方法），考虑到越来越大的邻域。输出层根据基因的输出概率将其分类为预测的癌症基因和非癌症基因。</p><p><strong>c</strong>, 使用LRP（见方法）提取每个基因分类的最重要的特征（包括不同癌症类型的全能性水平和相互作用伙伴）。随后根据基因的特征贡献进行聚类，每个基因的相互作用贡献被用来检测癌症中具有重要基因-基因联系的模块。</p></blockquote><p><em><a id="more"></a></em></p><h2 id="Nat-M-L-用于估计抗SARS-CoV-2活动的机器学习平台"><a href="#Nat-M-L-用于估计抗SARS-CoV-2活动的机器学习平台" class="headerlink" title="Nat. M.L. | 用于估计抗SARS-CoV-2活动的机器学习平台"></a>Nat. M.L. | 用于估计抗SARS-CoV-2活动的机器学习平台</h2><p>题目：A machine learning platform to estimate anti-SARS-CoV-2 activities</p><p>杂志：Nature Machine Intelligence</p><p>IF: 15</p><p>时间：13 May 2021</p><p>链接：<a href="https://www.nature.com/articles/s42256-021-00335-w" target="_blank" rel="noopener">https://www.nature.com/articles/s42256-021-00335-w</a></p><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>迫切需要针对COVID-19的药物发现和重新定位的策略。在此，我们提出了REDIAL-2020，一套用于估计小分子在一系列SARS-CoV-2相关检测中的活性的计算模型。模型是利用公开的高通量筛选数据，通过采用不同的描述符类型和各种机器学习策略来训练的。这里我们描述了11个模型的开发和使用，这些模型跨越了病毒进入、病毒复制、活病毒感染性、体外感染性和人类细胞毒性等领域。REDIAL-2020可通过DrugCentral网络门户（<a href="http://drugcentral.org/Redial）作为一个网络应用。该网络应用还提供相似性搜索结果，显示与查询最相似的分子，以及相关的实验数据。REDIAL-2020可以作为一个快速的在线工具，用于识别COVID-19治疗的活性分子。" target="_blank" rel="noopener">http://drugcentral.org/Redial）作为一个网络应用。该网络应用还提供相似性搜索结果，显示与查询最相似的分子，以及相关的实验数据。REDIAL-2020可以作为一个快速的在线工具，用于识别COVID-19治疗的活性分子。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nat-M-L-将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制&quot;&gt;&lt;a href=&quot;#Nat-M-L-将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制&quot; class=&quot;headerlink&quot; title=&quot;Nat. M.L. | 将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制&quot;&gt;&lt;/a&gt;Nat. M.L. | 将多组学数据与图卷积网络整合以识别新的癌症基因及其相关的分子机制&lt;/h2&gt;&lt;p&gt;题目：Integration of multiomics data with graph convolutional networks to identify new cancer genes and their associated molecular mechanisms&lt;/p&gt;
&lt;p&gt;杂志：Nature Machine Intelligence&lt;/p&gt;
&lt;p&gt;IF: 15&lt;/p&gt;
&lt;p&gt;时间：12 April 2021&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.nature.com/articles/s42256-021-00325-y&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nature.com/articles/s42256-021-00325-y&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;随着可用的高通量分子数据的增加，也为识别癌症基因带来了计算上的挑战。遗传和非遗传原因都有可能造成肿瘤的发生，这就需要开发预测模型来有效地整合不同的数据模式，同时具有可解释性。我们介绍了&lt;strong&gt;EMOGI&lt;/strong&gt;，这是一种基于图卷积网络的可解释的机器学习方法，其通过结合多组学的泛癌症数据来预测癌症基因，如突变、拷贝数变化、DNA甲基化和基因表达，蛋白质-蛋白质相互作用(PPI) 网络等。在不同的PPI网络和数据集中，EMOGI总体来说比其他方法更准确。我们使用分层相关性传播，根据基因的分类是由相互作用组还是由任何一个全向性水平驱动，对基因进行分层，并确定PPI网络的重要模块。我们提出了165个新的癌症基因，这些基因不一定有反复的改变，但与已知的癌症基因有相互作用。而且我们发现，这些基因与功能缺失筛查中的基本基因相对应。我们相信，我们的方法可以为精准肿瘤学开辟新的途径，并可应用于预测癌症的生物标志物。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/03/d7478ebb/image-20220203092107638.png&quot; alt=&quot;image-20220203092107638&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EMOGI框架的示意图。&lt;strong&gt;a, 数据收集和串联&lt;/strong&gt;。计算16个TCGA肿瘤类型的所有基因的平均突变率、CNAs、DNA甲基化和基因表达变化，并在一个早期整合方案中进行连接。然后将得到的特征矩阵与PPI网络和一小部分高置信度的癌症/非癌症基因相结合，形成一个网络，其中节点对应于基因，边对应于它们之间已知的相互作用。每个节点/基因都有一个多维的特征向量（b，输入层）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b&lt;/strong&gt;，在EMOGI模型训练期间，特征通过连续的图卷积层进行转化（见方法），考虑到越来越大的邻域。输出层根据基因的输出概率将其分类为预测的癌症基因和非癌症基因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c&lt;/strong&gt;, 使用LRP（见方法）提取每个基因分类的最重要的特征（包括不同癌症类型的全能性水平和相互作用伙伴）。随后根据基因的特征贡献进行聚类，每个基因的相互作用贡献被用来检测癌症中具有重要基因-基因联系的模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="federal learning" scheme="http://yoursite.com/tags/federal-learning/"/>
    
  </entry>
  
  <entry>
    <title>220202 | 文献摘要</title>
    <link href="http://yoursite.com/2022/02/02/f09c6d87.html"/>
    <id>http://yoursite.com/2022/02/02/f09c6d87.html</id>
    <published>2022-02-02T06:37:41.000Z</published>
    <updated>2022-02-02T08:01:46.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nat-M-L-通过学习随机掩码来解释生物序列的神经网络"><a href="#Nat-M-L-通过学习随机掩码来解释生物序列的神经网络" class="headerlink" title="Nat. M.L. | 通过学习随机掩码来解释生物序列的神经网络"></a>Nat. M.L. | 通过学习随机掩码来解释生物序列的神经网络</h2><p>题目：Interpreting neural networks for biological sequences by learning stochastic masks</p><p>杂志：Nature Machine Intelligence</p><p>IF: 15</p><p>时间：25 January 2022</p><p>链接：<a href="https://www.nature.com/articles/s42256-021-00428-6" target="_blank" rel="noopener">https://www.nature.com/articles/s42256-021-00428-6</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>基于序列的神经网络可以从大型生物数据集中学习从而做出准确的预测，但模型的解释仍然具有挑战性。许多现有的特征归属方法是针对连续的而不是离散的输入模式而优化的，并孤立地评估单个特征的重要性，使它们不适合解释分子序列中的非线性相互作用。在这里，在计算机视觉和自然语言处理的工作基础上，我们开发了一种基于<strong>深度学习-扰频器网络（Scrambler networks）</strong>的方法，其中最重要的序列位置是通过学习<strong>输入掩码(input masks)</strong>确定的。扰频器学习预测特定位置的评分矩阵，其中不重要的核苷酸或残基通过提高其熵值而被扰乱。我们应用加扰频器来解释遗传变异的影响，发现顺式调控元素之间的非线性相互作用，解释蛋白质-蛋白质相互作用的结合特异性，并确定从头设计的蛋白质的结构决定因素。我们表明，扰频器能够在大型数据集上进行有效的归因，并产生高质量的解释，往往优于最先进的方法。</p><p><img src="/2022/02/02/f09c6d87/image-20220202083212293.png" alt="image-20220202083212293" style="zoom:50%;"></p><p><em><a id="more"></a></em></p><h2 id="Nat-M-L-通过人工智能中的隐私保护协作推进-COVID-19-诊断"><a href="#Nat-M-L-通过人工智能中的隐私保护协作推进-COVID-19-诊断" class="headerlink" title="Nat. M.L. | 通过人工智能中的隐私保护协作推进 COVID-19 诊断"></a>Nat. M.L. | 通过人工智能中的隐私保护协作推进 COVID-19 诊断</h2><p>题目：Advancing COVID-19 diagnosis with privacy-preserving collaboration in artificial intelligence</p><p>杂志：Nature Machine Intelligence</p><p>IF: 15</p><p>时间：15 December 2021</p><p>链接：<a href="https://www.nature.com/articles/s42256-021-00421-z" target="_blank" rel="noopener">https://www.nature.com/articles/s42256-021-00421-z</a></p><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>人工智能为COVID-19的诊断提供了一个有希望的解决方案，然而，围绕安全和可信度的担扰阻碍了大规模代表性医疗数据的收集，为在临床实践中训练一个通用的模型带来了相当大的挑战。为了解决这个问题，我们发起了统一CT-COVID人工智能诊断计划<strong>（Unified CT-COVID AI Diagnostic Initiative，UCADI）</strong>，人工智能模型可以在一个联邦学习框架（<strong>federated learning</strong>）下分布式地训练并在每个主办机构独立执行，而不需要分享数据。这里显示我们的联邦学习框架大大超过了所有的本地模型（在中国的测试灵敏度/特异性为0.973/0.951，在英国为0.730/0.942），达到了与专业放射医师小组相当的性能。我们进一步评估了该模型在保留（从另外两家医院收集的没有联合学习框架的数据）和异质（用造影剂获得）数据上的表现，为模型做出的决定提供了可视化的解释，并分析了模型性能和联邦训练过程中沟通成本之间的权衡。我们的研究是基于从中国和英国的23家医院收集的3336名患者的9573张胸部计算机断层扫描。总的来说，我们的工作推进了利用联合学习在数字健康领域保护隐私的人工智能的前景。</p><p><img src="/2022/02/02/f09c6d87/image-20220202085203685.png" alt="image-20220202085203685" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nat-M-L-通过学习随机掩码来解释生物序列的神经网络&quot;&gt;&lt;a href=&quot;#Nat-M-L-通过学习随机掩码来解释生物序列的神经网络&quot; class=&quot;headerlink&quot; title=&quot;Nat. M.L. | 通过学习随机掩码来解释生物序列的神经网络&quot;&gt;&lt;/a&gt;Nat. M.L. | 通过学习随机掩码来解释生物序列的神经网络&lt;/h2&gt;&lt;p&gt;题目：Interpreting neural networks for biological sequences by learning stochastic masks&lt;/p&gt;
&lt;p&gt;杂志：Nature Machine Intelligence&lt;/p&gt;
&lt;p&gt;IF: 15&lt;/p&gt;
&lt;p&gt;时间：25 January 2022&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.nature.com/articles/s42256-021-00428-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nature.com/articles/s42256-021-00428-6&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;基于序列的神经网络可以从大型生物数据集中学习从而做出准确的预测，但模型的解释仍然具有挑战性。许多现有的特征归属方法是针对连续的而不是离散的输入模式而优化的，并孤立地评估单个特征的重要性，使它们不适合解释分子序列中的非线性相互作用。在这里，在计算机视觉和自然语言处理的工作基础上，我们开发了一种基于&lt;strong&gt;深度学习-扰频器网络（Scrambler networks）&lt;/strong&gt;的方法，其中最重要的序列位置是通过学习&lt;strong&gt;输入掩码(input masks)&lt;/strong&gt;确定的。扰频器学习预测特定位置的评分矩阵，其中不重要的核苷酸或残基通过提高其熵值而被扰乱。我们应用加扰频器来解释遗传变异的影响，发现顺式调控元素之间的非线性相互作用，解释蛋白质-蛋白质相互作用的结合特异性，并确定从头设计的蛋白质的结构决定因素。我们表明，扰频器能够在大型数据集上进行有效的归因，并产生高质量的解释，往往优于最先进的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/02/02/f09c6d87/image-20220202083212293.png&quot; alt=&quot;image-20220202083212293&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="federal learning" scheme="http://yoursite.com/tags/federal-learning/"/>
    
  </entry>
  
  <entry>
    <title>综述｜利用深度学习进行多组学数据整合的路线图</title>
    <link href="http://yoursite.com/2022/01/11/7b8ddaea.html"/>
    <id>http://yoursite.com/2022/01/11/7b8ddaea.html</id>
    <published>2022-01-11T20:15:28.867Z</published>
    <updated>2022-02-02T08:00:12.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：A roadmap for multi-omics data integration using deep learning</p><p>杂志：Briefings in Bioinformatics</p><p>IF: 11.62</p><p>时间：12 November 2021</p><p>链接：<a href="https://doi.org/10.1093/bib/bbab454" target="_blank" rel="noopener">https://doi.org/10.1093/bib/bbab454</a></p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>介绍了利用深度学习对多组学数据的整合和应用以及优缺点</p><p><img src="/2022/01/11/7b8ddaea/image-20220202090004483.png" alt="image-20220202090004483"></p><a id="more"></a><h2 id="文章信息-1"><a href="#文章信息-1" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Integrating multi-omics data through deep learning for accurate cancer prognosis prediction</p><p>杂志：Computers in Biology and Medicine</p><p>IF: 4.589</p><p>时间：July 2021</p><p>链接：<a href="https://doi.org/10.1016/j.compbiomed.2021.104481" target="_blank" rel="noopener">https://doi.org/10.1016/j.compbiomed.2021.104481</a></p><p>代码： <a href="https://github.com/Hua0113/DCAP" target="_blank" rel="noopener">https://github.com/Hua0113/DCAP</a></p><h2 id="一句话评价-1"><a href="#一句话评价-1" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>通过深度学习整合多组学数据以进行准确的癌症预后预测</p><p><img src="/2022/01/11/7b8ddaea/image-20220111213116633.png" alt="image-20220111213116633"></p><ul><li><p>开发了一种新的多组学方法，在<strong>去噪自动编码器</strong>的基础上准确预测癌症的预后。</p></li><li><p>一个仅使用mRNA数据的轻量级模型在三个外部GEO数据集上得到了独立验证。</p></li><li><p>一个仅使用mRNA数据的轻量级模型在三个外部GEO数据集上得到了独立验证。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：A roadmap for multi-omics data integration using deep learning&lt;/p&gt;
&lt;p&gt;杂志：Briefings in Bioinformatics&lt;/p&gt;
&lt;p&gt;IF: 11.62&lt;/p&gt;
&lt;p&gt;时间：12 November 2021&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://doi.org/10.1093/bib/bbab454&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://doi.org/10.1093/bib/bbab454&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一句话评价&quot;&gt;&lt;a href=&quot;#一句话评价&quot; class=&quot;headerlink&quot; title=&quot;一句话评价&quot;&gt;&lt;/a&gt;一句话评价&lt;/h2&gt;&lt;p&gt;介绍了利用深度学习对多组学数据的整合和应用以及优缺点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/11/7b8ddaea/image-20220202090004483.png&quot; alt=&quot;image-20220202090004483&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>乳腺癌治疗反应的多组学机器学习预测器</title>
    <link href="http://yoursite.com/2022/01/10/dfeeb526.html"/>
    <id>http://yoursite.com/2022/01/10/dfeeb526.html</id>
    <published>2022-01-10T22:29:43.000Z</published>
    <updated>2022-01-10T23:08:46.388Z</updated>
    
    <content type="html"><![CDATA[<p>题目：Multi-omic machine learning predictor of breast cancer therapy response</p><p>杂志：Nature</p><p>IF: 49.96</p><p>时间：7 Dec. 2021</p><p>链接：<a href="https://www.nature.com/articles/s41586-021-04278-5" target="_blank" rel="noopener">https://www.nature.com/articles/s41586-021-04278-5</a></p><p>代码：</p><ul><li><a href="https://github.com/micrisor/NAT-ML" target="_blank" rel="noopener">https://github.com/micrisor/NAT-ML</a></li><li><a href="https://github.com/cclab-brca/neoadjuvant-therapy-response-predictor" target="_blank" rel="noopener">https://github.com/cclab-brca/neoadjuvant-therapy-response-predictor</a></li></ul><h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><p>使用逻辑回归，SVM和随机森林的组合机器学习方法，结合临床数据、数字病理学数据、基因组和转录组学数据，对乳腺癌治疗的反应进行预测</p><p>###摘要</p><p>乳腺癌是由恶性细胞和肿瘤微环境组成的复杂生态系统。这些肿瘤生态系统的组成和其中的相互作用有助于细胞毒性治疗反应。构建细胞毒性治疗反应的预测器还有待研究。这篇文章收集了<strong>168名</strong>患者在手术前接受化疗+/-HER2靶向治疗的乳腺肿瘤治疗前活检的<strong>临床、数字病理学、基因组和转录组资料</strong>。然后将手术时的病理终点（完全反应或残余疾病）与这些诊断性活检的多组学特征相关联。他们发现，对治疗的反应是由预处理的肿瘤生态系统调节的，其多组学景观可以用机器学习整合到预测模型中。治疗后残余疾病的程度与治疗前的特征单调相关，包括<strong>肿瘤突变和拷贝数变异、肿瘤增殖、免疫浸润和T细胞功能紊乱和排斥</strong>。将这些特征结合到一个多组学机器学习模型中，可预测外部验证队列（75名患者）的病理完全反应，AUC为0.87。总之，对治疗的反应是由通过数据整合和机器学习捕获的整个肿瘤生态系统的基线特征决定的。这种方法可用于开发其他癌症的预测器。</p><p><img src="/2022/01/10/dfeeb526/image-20220111000724850.png" alt="image-20220111000724850"></p><p><img src="/2022/01/10/dfeeb526/image-20220111000748893.png" alt="image-20220111000748893"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：Multi-omic machine learning predictor of breast cancer therapy response&lt;/p&gt;
&lt;p&gt;杂志：Nature&lt;/p&gt;
&lt;p&gt;IF: 49.96&lt;/p&gt;
&lt;p&gt;时间：7 Dec. 2021&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>211012｜文献摘要</title>
    <link href="http://yoursite.com/2021/10/12/b83dc028.html"/>
    <id>http://yoursite.com/2021/10/12/b83dc028.html</id>
    <published>2021-10-12T18:49:03.000Z</published>
    <updated>2021-10-12T19:27:29.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nat-Biotechnol-通过迁移学习将单细胞数据映射到参考图谱"><a href="#Nat-Biotechnol-通过迁移学习将单细胞数据映射到参考图谱" class="headerlink" title="Nat. Biotechnol. | 通过迁移学习将单细胞数据映射到参考图谱"></a>Nat. Biotechnol. | 通过迁移学习将单细胞数据映射到参考图谱</h2><p>题目：Mapping single-cell data to reference atlases by transfer learning</p><p>杂志：Nature Biotechnology</p><p>IF: 54.91</p><p>时间：30 August 2021</p><p>链接：<a href="https://www.nature.com/articles/s41587-021-01001-7" target="_blank" rel="noopener">https://www.nature.com/articles/s41587-021-01001-7</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>现在，大型单细胞图谱被不断地生成，作为分析较小规模研究的参考。然而，由于数据集之间的批次效应、计算资源的有限可用性和原始数据的共享限制，从参考数据中学习是复杂的。在这里，我们介绍了一种深度学习策略，用于在称为单细胞结构手术（single-cell architectural surgery，scArches）的参考之上映射查询数据集。scArches使用转移学习和参数优化来实现高效、分散、迭代的参考构建和新数据集与现有参考的上下文关系，而无需分享原始数据。利用小鼠大脑、胰腺、免疫和全生物体图谱的例子，我们表明scArches保留了生物状态信息，同时消除了批量效应，而且使用的参数比从头整合少四个数量级。最后，scArches在映射到健康参照物时保留了COVID-19的疾病变异，从而能够发现疾病特定的细胞状态。scArches将通过实现参照物图谱的迭代构建、更新、共享和有效使用来促进合作项目。</p><p><img src="/2021/10/12/b83dc028/image-20211012210720260.png" alt="image-20211012210720260"></p><p><em><a id="more"></a></em></p><h2 id="Nat-Commu-深度迁移学习用于减少由于生物医学数据不平等引起的医疗保健差异"><a href="#Nat-Commu-深度迁移学习用于减少由于生物医学数据不平等引起的医疗保健差异" class="headerlink" title="Nat. Commu. | 深度迁移学习用于减少由于生物医学数据不平等引起的医疗保健差异"></a>Nat. Commu. | 深度迁移学习用于减少由于生物医学数据不平等引起的医疗保健差异</h2><p>题目：Deep transfer learning for reducing health care disparities arising from biomedical data inequality</p><p>杂志：Nature Communication</p><p>IF: 14.92</p><p>时间：30 December 2020</p><p>链接：<a href="https://www.nature.com/articles/s41467-020-18918-3" target="_blank" rel="noopener">https://www.nature.com/articles/s41467-020-18918-3</a></p><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>随着人工智能（AI）越来越多地应用于生物医学研究和临床决策，开发对所有种族群体同样有效的无偏见的AI模型对预防和减少健康差异至关重要。然而，通过数据驱动的、基于算法的生物医学研究和临床决策，不同族裔群体之间的生物医学数据不平等将产生新的医疗保健差异。通过对癌症全向数据进行大量的机器学习实验，我们发现目前流行的多民族机器学习方案容易在不同民族之间产生明显的模型性能差异。我们表明，这些性能差异是由族群之间的数据不平等和数据分布差异造成的。我们还发现，<strong>转移学习可以改善处于数据劣势的民族群体的机器学习模型性能，从而为减少民族群体之间的数据不平等造成的医疗差异提供了有效的方法</strong>。</p><p><img src="/2021/10/12/b83dc028/image-20211012211618511.png" alt="image-20211012211618511"></p><h2 id="Nat-Commu-使用二维深度神经网络和迁移学习的组合预测RNA二级结构"><a href="#Nat-Commu-使用二维深度神经网络和迁移学习的组合预测RNA二级结构" class="headerlink" title="Nat. Commu. | 使用二维深度神经网络和迁移学习的组合预测RNA二级结构"></a>Nat. Commu. | 使用二维深度神经网络和迁移学习的组合预测RNA二级结构</h2><p>题目：RNA secondary structure prediction using an ensemble of two-dimensional deep neural networks and transfer learning</p><p>杂志：Nature Communication</p><p>IF: 14.92</p><p>时间：27 November 2019</p><p>链接：<a href="https://www.nature.com/articles/s41467-019-13395-9" target="_blank" rel="noopener">https://www.nature.com/articles/s41467-019-13395-9</a></p><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>我们人类基因组的大部分转录为结构和功能未知的非编码RNA。获得非编码RNA的功能线索需要准确的碱基配对或二级结构预测。然而，目前基于折叠的算法对这种预测的表现已经停滞了十多年。在这里，我们提出使用深度上下文学习来预测碱基对，包括那些由三级相互作用稳定的非经典和非嵌套（假结）碱基对。由于只有&lt;250个非冗余的、高分辨率的RNA结构可用于模型训练，我们利用转移学习，从一个最初用&gt;10,000个非冗余RNA的最近高质量bpRNA数据集训练出来的模型。由此产生的方法在预测所有碱基对，特别是非经典碱基对和非嵌套碱基对方面取得了很大的、有统计学意义的改进。所提出的方法（SPOT-RNA），有免费的服务器和独立的软件，应该对改善RNA结构建模、序列比对和功能注释有帮助。</p><p><img src="/2021/10/12/b83dc028/image-20211012212552824.png" alt="image-20211012212552824" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nat-Biotechnol-通过迁移学习将单细胞数据映射到参考图谱&quot;&gt;&lt;a href=&quot;#Nat-Biotechnol-通过迁移学习将单细胞数据映射到参考图谱&quot; class=&quot;headerlink&quot; title=&quot;Nat. Biotechnol. | 通过迁移学习将单细胞数据映射到参考图谱&quot;&gt;&lt;/a&gt;Nat. Biotechnol. | 通过迁移学习将单细胞数据映射到参考图谱&lt;/h2&gt;&lt;p&gt;题目：Mapping single-cell data to reference atlases by transfer learning&lt;/p&gt;
&lt;p&gt;杂志：Nature Biotechnology&lt;/p&gt;
&lt;p&gt;IF: 54.91&lt;/p&gt;
&lt;p&gt;时间：30 August 2021&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.nature.com/articles/s41587-021-01001-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nature.com/articles/s41587-021-01001-7&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;现在，大型单细胞图谱被不断地生成，作为分析较小规模研究的参考。然而，由于数据集之间的批次效应、计算资源的有限可用性和原始数据的共享限制，从参考数据中学习是复杂的。在这里，我们介绍了一种深度学习策略，用于在称为单细胞结构手术（single-cell architectural surgery，scArches）的参考之上映射查询数据集。scArches使用转移学习和参数优化来实现高效、分散、迭代的参考构建和新数据集与现有参考的上下文关系，而无需分享原始数据。利用小鼠大脑、胰腺、免疫和全生物体图谱的例子，我们表明scArches保留了生物状态信息，同时消除了批量效应，而且使用的参数比从头整合少四个数量级。最后，scArches在映射到健康参照物时保留了COVID-19的疾病变异，从而能够发现疾病特定的细胞状态。scArches将通过实现参照物图谱的迭代构建、更新、共享和有效使用来促进合作项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/10/12/b83dc028/image-20211012210720260.png&quot; alt=&quot;image-20211012210720260&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="transfer learning" scheme="http://yoursite.com/tags/transfer-learning/"/>
    
  </entry>
  
  <entry>
    <title>211011-｜文献摘要</title>
    <link href="http://yoursite.com/2021/10/11/754b48bf.html"/>
    <id>http://yoursite.com/2021/10/11/754b48bf.html</id>
    <published>2021-10-11T20:04:24.000Z</published>
    <updated>2021-10-11T20:19:25.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Brief-Bioinformatics-DeepHost：用卷积神经网络进行噬菌体宿主预测"><a href="#Brief-Bioinformatics-DeepHost：用卷积神经网络进行噬菌体宿主预测" class="headerlink" title="Brief. Bioinformatics | DeepHost：用卷积神经网络进行噬菌体宿主预测"></a>Brief. Bioinformatics | DeepHost：用卷积神经网络进行噬菌体宿主预测</h2><p>题目：DeepHost: phage host prediction with convolutional neural network</p><p>杂志：Briefings in Bioinformatics</p><p>IF: 11.62</p><p>时间：22 September 2021</p><p>链接：<a href="https://doi.org/10.1093/bib/bbab385" target="_blank" rel="noopener">https://doi.org/10.1093/bib/bbab385</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>新一代测序技术迅速扩大了已知的噬菌体基因组。与基于培养的方法不同，从下一代测序数据中发现的噬菌体的宿主仍未被描述。噬菌体基因组的高度多样性使得宿主分配任务具有挑战性。为了解决这个问题，我们提出了一个噬菌体宿主预测工具-DeepHost。为了将噬菌体基因组编码成矩阵，我们设计了一种基因组编码方法，应用各种间隔的<strong>K-mer对</strong>来容忍序列变化，包括插入、删除和突变。DeepHost应用卷积神经网络来预测宿主分类法。DeepHost在属级（72个分类群）的预测准确率为96.05%，在种级（118个分类群）的预测准确率为90.78%，比现有的噬菌体宿主预测工具高出10.16-30.48%，取得了与BLAST相当的结果。对于在BLAST中没有命中的基因组，DeepHost在属级获得了38.00%的准确率，在种级获得了26.47%的准确率，使其适用于与现有数据集同源序列较少的基因组。DeepHost是alignment-free的，它比BLAST快，特别是对大的数据集。DeepHost可在<a href="https://github.com/deepomicslab/DeepHost。" target="_blank" rel="noopener">https://github.com/deepomicslab/DeepHost。</a></p><p><strong>文章思路</strong></p><p><img src="/2021/10/11/754b48bf/image-20211011221810475.png" alt="image-20211011221810475"></p><p><strong>基因组序列编码方法：</strong></p><p><img src="/2021/10/11/754b48bf/image-20211011221515028.png" alt="image-20211011221515028"></p><blockquote><p><em>Illustration of the matrix construction process. Given a DNA sequence, all possible 2-mer pairs are collected with spaced distance of 0 (upper) and 1 (lower). For each distance, we construct two matrices.</em></p></blockquote><p><strong>CNN 架构</strong></p><p><img src="/2021/10/11/754b48bf/image-20211011221657856.png" alt="image-20211011221657856"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Brief-Bioinformatics-DeepHost：用卷积神经网络进行噬菌体宿主预测&quot;&gt;&lt;a href=&quot;#Brief-Bioinformatics-DeepHost：用卷积神经网络进行噬菌体宿主预测&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="CNN" scheme="http://yoursite.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>210930 ｜文献摘要</title>
    <link href="http://yoursite.com/2021/09/30/45570cbd.html"/>
    <id>http://yoursite.com/2021/09/30/45570cbd.html</id>
    <published>2021-09-30T18:31:43.000Z</published>
    <updated>2021-10-11T20:08:04.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Brief-Bioinformatics-｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法"><a href="#Brief-Bioinformatics-｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法" class="headerlink" title="Brief. Bioinformatics ｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法"></a>Brief. Bioinformatics ｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法</h2><p>题目：Assessing deep learning methods in cis-regulatory motif finding based on genomic sequencing data</p><p>杂志：Briefings in Bioinformatics</p><p>IF: 11.62</p><p>时间：05 October 2021</p><p>链接：<a href="https://doi.org/10.1093/bib/bbab374" target="_blank" rel="noopener">https://doi.org/10.1093/bib/bbab374</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>从基因组测序数据（如ChIP-seq和CLIP-seq）中识别顺式调控基序，对于识别转录因子（TF）结合位点和推断任何生物体的基因调控机制至关重要。自2015年以来，深度学习（DL）方法已被广泛用于识别TF结合位点和预测基序，其优点是提供一个可扩展的、灵活的和统一的计算方法，以实现高度准确的预测。目前已经开发了20种DL方法。然而，如果没有一个明确和系统的评估，用户将很难为他们的具体研究选择最合适的工具。在这份研究中，他们使用<strong>690个ENCODE ChIP-seq、126个癌症ChIP-seq和55个RNA CLIP-seq数据评估了20种顺式调控图案预测的DL方法</strong>。他们评估了四个指标，包括发现动机的准确性、DNA/RNA序列分类的性能、算法的可扩展性和工具的可用性。评估结果证明了现有DL方法的高度互补性。确定最适合的模型应主要取决于数据的大小和类型以及方法的输出。</p><p><img src="/2021/09/30/45570cbd/image-20211011215253621.png" alt="image-20211011215253621" style="zoom:50%;"></p><p><img src="/2021/09/30/45570cbd/image-20211011215337568.png" alt="image-20211011215337568"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Brief-Bioinformatics-｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法&quot;&gt;&lt;a href=&quot;#Brief-Bioinformatics-｜评估基于基因组测序数据寻找顺式调控基序的深度学习方法&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>210929 ｜文献摘要</title>
    <link href="http://yoursite.com/2021/09/29/cbb33e81.html"/>
    <id>http://yoursite.com/2021/09/29/cbb33e81.html</id>
    <published>2021-09-29T10:32:05.000Z</published>
    <updated>2021-09-29T11:38:32.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Commun-Biol-Review-人工智能加速抗生素发现"><a href="#Commun-Biol-Review-人工智能加速抗生素发现" class="headerlink" title="Commun. Biol. | Review | 人工智能加速抗生素发现"></a>Commun. Biol. | Review | 人工智能加速抗生素发现</h2><p>题目：Accelerating antibiotic discovery through artificial intelligence</p><p>杂志：Communication Biology</p><p>IF: 6.268</p><p>时间：09 September 2021</p><p>链接：<a href="https://doi.org/10.1038/s42003-021-02586-0" target="_blank" rel="noopener">https://doi.org/10.1038/s42003-021-02586-0</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>通过靶向结合入侵的生物体，抗生素将自己插入宿主-病原体进化军备竞赛的古老斗争中。随着病原体进化出躲避抗生素的策略，治疗的疗效也逐渐下降，而且必须被取代，这使抗生素与大多数其他形式的药物开发不同。再加上缓慢而昂贵的抗生素开发管道，耐药性病原体的扩散促使人们对有望加快候选药物发现的计算方法产生迫切的兴趣。人工智能（AI）的不断发展鼓励其应用于计算机辅助药物设计的多个层面，并越来越多地应用于抗生素发现。</p><p>这篇综述描述了<br>1）人工智能在发现小分子抗生素和抗菌肽方面的进展。<br>2）除了对抗菌活性的基本预测外，还强调了抗菌化合物的代表性、药物相似性特征的确定、抗菌剂的抗性和新分子设计。<br>3）分析了人工智能驱动的抗生素发现中对开放科学最佳实践的吸收情况，并主张将开放性和可重复性作为加速临床前研究的手段。<br>4）最后，讨论了文献中的趋势和未来探索的领域。</p><p><strong>抗生素发现的相关数据库</strong></p><p><img src="/2021/09/29/cbb33e81/image-20210929133826090.png" alt="image-20210929133826090" style="zoom:50%;"></p><p><strong>计算方法发现抗生素的流程</strong></p><p><img src="/2021/09/29/cbb33e81/image-20210929125714699.png" alt="image-20210929125714699" style="zoom:50%;"></p><p><em><a id="more"></a></em></p><h2 id="Brief-Bioinformatics-｜深度神经网络的基因连接矩阵对三阴性乳腺癌亚型分类和基因选择"><a href="#Brief-Bioinformatics-｜深度神经网络的基因连接矩阵对三阴性乳腺癌亚型分类和基因选择" class="headerlink" title="Brief. Bioinformatics ｜深度神经网络的基因连接矩阵对三阴性乳腺癌亚型分类和基因选择"></a>Brief. Bioinformatics ｜深度神经网络的基因连接矩阵对三阴性乳腺癌亚型分类和基因选择</h2><p>题目：Classification and gene selection of triple-negative breast cancer subtype embedding gene connectivity matrix in deep neural network</p><p>杂志：Briefings in Bioinformatics</p><p>IF: 11.62</p><p>时间：05 September 2021</p><p>链接：<a href="https://doi.org/10.1093/bib/bbaa395" target="_blank" rel="noopener">https://doi.org/10.1093/bib/bbaa395</a></p><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>三阴性乳腺癌（TNBC）一直是肿瘤学治疗中具有挑战性的乳腺癌亚型。通常情况下，它可以被划分为不同的分子亚型。对这六种亚型进行准确和稳定的分类对于TNBC的个性化治疗至关重要。在这项研究中，作者提出了一个新的框架来区分TNBC的六个亚型，这也是少数几个基于<strong>mRNA和长非编码RNA表达数据</strong> 完成分类的研究之一。特别是，他们开发了一种名为<strong>DGGA的基因选择方法</strong>，该方法在衡量基因重要性的过程中考虑了基因之间的相关信息（WGCNA），然后有效地去除多余的基因。他们提出了一种基因评分方法，将GeneRank分数与深度神经网络（DNN）产生的基因重要性结合起来，考虑到亚型间的鉴别和基因内部的相关性，以提高基因选择性能。更重要的是，他们在DNN中嵌入了基因连接矩阵进行稀疏学习，在获得每个基因的相对重要性的测量时，会额外考虑训练过程中的权重变化。最后，遗传算法被用来模拟自然进化过程，以寻找TNBC亚型分类的最佳子集。他们通过交叉验证来验证所提出的方法，结果表明它可以使用较少的基因来获得更准确的分类结果。</p><p>代码在：<a href="https://github.com/RanSuLab/TNBC。" target="_blank" rel="noopener">https://github.com/RanSuLab/TNBC。</a></p><p><img src="/2021/09/29/cbb33e81/image-20210929131232918.png" alt="image-20210929131232918" style="zoom:50%;"></p><h2 id="Brief-Bioinformatics-｜DeepCNV：一种用于验证拷贝数变异-CNV-的深度学习方法"><a href="#Brief-Bioinformatics-｜DeepCNV：一种用于验证拷贝数变异-CNV-的深度学习方法" class="headerlink" title="Brief. Bioinformatics ｜DeepCNV：一种用于验证拷贝数变异 (CNV) 的深度学习方法"></a>Brief. Bioinformatics ｜DeepCNV：一种用于验证拷贝数变异 (CNV) 的深度学习方法</h2><p>题目：DeepCNV: a deep learning approach for authenticating copy number variations</p><p>杂志：Briefings in Bioinformatics</p><p>IF: 11.62</p><p>时间：05 September 2021</p><p>链接：<a href="https://doi.org/10.1093/bib/bbaa381" target="_blank" rel="noopener">https://doi.org/10.1093/bib/bbaa381</a></p><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>拷贝数变异（CNVs）是一类重要的变异，有助于许多疾病表型的发病机制。从基因组数据中检测CNVs仍然很困难，目前应用的大多数方法都存在不可接受的高假阳性率。一个常见的做法是在进一步的下游分析或实验验证之前，由人类专家手动审查原始的CNV调用以过滤假阳性。在这里，他们提出了DeepCNV，一个基于深度学习的工具，目的是在验证CNV调用时取代人类专家，重点是由最准确的CNV调用者之一PennCNV进行调用。深度神经网络算法的复杂性被超过10 000个专家评分的样本所丰富，这些样本被分成训练和测试集。变种的置信度，特别是对于CNVs，是阻碍CNVs与疾病联系起来的主要障碍。结果表明，DeepCNV增加了CNV调用的置信度，其最佳接收者操作特征曲线下面积为0.909，超过了其他机器学习方法。DeepCNV的优越性也通过实验性的湿实验室验证数据集进行了基准测试和确认。我们得出结论，DeepCNV获得的改进使假阳性结果和复制CNV关联结果的失败明显减少。</p><h3 id="CNV图像产生的方法：-PennCNV"><a href="#CNV图像产生的方法：-PennCNV" class="headerlink" title="CNV图像产生的方法： PennCNV"></a>CNV图像产生的方法： PennCNV</h3><p>为了直观地检查CNV调用并判断它们是否为真阳性，我们利用PennCNV提供的辅助可视化程序（visualize_cnv.pl）为CNV调用自动生成图像文件。对于每个CNV调用，它产生一个LRR散点图图像和一个BAF散点图图像。这些图涵盖了一个候选的CNV片段和它的周围区域。LRR图为该区域（候选CNV+其扩展区域）中的每个SNP基因分型画一个点，染色体位置为X坐标，LRR为Y坐标。BAF图以类似的图覆盖同一区域，但使用BAF作为Y坐标。对于这两张图，我们将候选CNV中的SNPs（点）涂成红色，将周围区域的SNPs涂成蓝色。然后，具有CNV调用专业知识的科学家根据视觉效果将它们标记为假阳性或真阳性。图1描述了样本图像。这些图像被用作DeepCNV的输入。图像中的像素范围从0到255。按照标准的图像缩放操作，我们通过将每个像素除以255来规范像素值，因此新的值在0和1之间，供DeepCNV使用。</p><p><img src="/2021/09/29/cbb33e81/image-20210929131744683.png" alt="image-20210929131744683" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Commun-Biol-Review-人工智能加速抗生素发现&quot;&gt;&lt;a href=&quot;#Commun-Biol-Review-人工智能加速抗生素发现&quot; class=&quot;headerlink&quot; title=&quot;Commun. Biol. | Review | 人工智能加速抗生素发现&quot;&gt;&lt;/a&gt;Commun. Biol. | Review | 人工智能加速抗生素发现&lt;/h2&gt;&lt;p&gt;题目：Accelerating antibiotic discovery through artificial intelligence&lt;/p&gt;
&lt;p&gt;杂志：Communication Biology&lt;/p&gt;
&lt;p&gt;IF: 6.268&lt;/p&gt;
&lt;p&gt;时间：09 September 2021&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://doi.org/10.1038/s42003-021-02586-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://doi.org/10.1038/s42003-021-02586-0&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;通过靶向结合入侵的生物体，抗生素将自己插入宿主-病原体进化军备竞赛的古老斗争中。随着病原体进化出躲避抗生素的策略，治疗的疗效也逐渐下降，而且必须被取代，这使抗生素与大多数其他形式的药物开发不同。再加上缓慢而昂贵的抗生素开发管道，耐药性病原体的扩散促使人们对有望加快候选药物发现的计算方法产生迫切的兴趣。人工智能（AI）的不断发展鼓励其应用于计算机辅助药物设计的多个层面，并越来越多地应用于抗生素发现。&lt;/p&gt;
&lt;p&gt;这篇综述描述了&lt;br&gt;1）人工智能在发现小分子抗生素和抗菌肽方面的进展。&lt;br&gt;2）除了对抗菌活性的基本预测外，还强调了抗菌化合物的代表性、药物相似性特征的确定、抗菌剂的抗性和新分子设计。&lt;br&gt;3）分析了人工智能驱动的抗生素发现中对开放科学最佳实践的吸收情况，并主张将开放性和可重复性作为加速临床前研究的手段。&lt;br&gt;4）最后，讨论了文献中的趋势和未来探索的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抗生素发现的相关数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/09/29/cbb33e81/image-20210929133826090.png&quot; alt=&quot;image-20210929133826090&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算方法发现抗生素的流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/09/29/cbb33e81/image-20210929125714699.png&quot; alt=&quot;image-20210929125714699&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="AMR" scheme="http://yoursite.com/tags/AMR/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="药物研发" scheme="http://yoursite.com/tags/%E8%8D%AF%E7%89%A9%E7%A0%94%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>整合多组学数据和图像卷积网络鉴定新的癌症基因和相关的分子机制</title>
    <link href="http://yoursite.com/2021/09/19/f8c75c1b.html"/>
    <id>http://yoursite.com/2021/09/19/f8c75c1b.html</id>
    <published>2021-09-19T20:30:07.000Z</published>
    <updated>2021-09-19T20:52:08.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Integration of multiomics data with graph convolutional networks to identify new cancer genes and their associated molecular mechanisms</p><p>杂志：Nature Machine Intelligence</p><p>IF:16.65</p><p>时间：12 April 2021</p><p>链接：<a href="https://www.nature.com/articles/s42256-021-00325-y" target="_blank" rel="noopener">https://www.nature.com/articles/s42256-021-00325-y</a></p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>使用机器学习方法——图像卷积网络对多组学数据（SNPs, CNV，DAN methylation，protein interaction (PPI) networks）进行挖掘，预测新的癌症基因以及这些基因发挥功能的机制。</p><p><img src="/2021/09/19/f8c75c1b/image-20210919224314468.png" alt="image-20210919224314468" style="zoom:50%;"></p><p><img src="/2021/09/19/f8c75c1b/image-20210919224447370.png" alt="image-20210919224447370"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：Integration of multiomics data with graph convolutional net
      
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="CNN" scheme="http://yoursite.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>多标签分类提高耐药性预测能力</title>
    <link href="http://yoursite.com/2021/04/04/c387b45f.html"/>
    <id>http://yoursite.com/2021/04/04/c387b45f.html</id>
    <published>2021-04-04T08:19:04.000Z</published>
    <updated>2021-04-11T22:20:51.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Exploiting HIV-1 protease and reverse transcriptase cross-resistance information for improved drug resistance prediction by means of multi-label classification</p><p>杂志：BioData Mining</p><p>IF: 2.672</p><p>时间：2016</p><p>链接：DOI 10.1186/s13040-016-0089-1</p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>多标签分类应用</p><a id="more"></a><h2 id="文章介绍"><a href="#文章介绍" class="headerlink" title="文章介绍"></a>文章介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>（背景，亮点，方法，结果，意义）</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>（详细解读）</p><h3 id="结果和结论"><a href="#结果和结论" class="headerlink" title="结果和结论"></a>结果和结论</h3><p>（简要，理顺逻辑）</p><h3 id="创新性和意义"><a href="#创新性和意义" class="headerlink" title="创新性和意义"></a>创新性和意义</h3><p>（思路，方法或者数据资源对自己有什么启示）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：Exploiting HIV-1 protease and reverse transcriptase cross-resistance information for improved drug resistance prediction by means of multi-label classification&lt;/p&gt;
&lt;p&gt;杂志：BioData Mining&lt;/p&gt;
&lt;p&gt;IF: 2.672&lt;/p&gt;
&lt;p&gt;时间：2016&lt;/p&gt;
&lt;p&gt;链接：DOI 10.1186/s13040-016-0089-1&lt;/p&gt;
&lt;h2 id=&quot;一句话评价&quot;&gt;&lt;a href=&quot;#一句话评价&quot; class=&quot;headerlink&quot; title=&quot;一句话评价&quot;&gt;&lt;/a&gt;一句话评价&lt;/h2&gt;&lt;p&gt;多标签分类应用&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="AMR" scheme="http://yoursite.com/tags/AMR/"/>
    
      <category term="multi-label classification" scheme="http://yoursite.com/tags/multi-label-classification/"/>
    
  </entry>
  
  <entry>
    <title>在HIV-1耐药性预测中利用交叉耐药信息的多标签分类方法</title>
    <link href="http://yoursite.com/2021/04/03/f1069cae.html"/>
    <id>http://yoursite.com/2021/04/03/f1069cae.html</id>
    <published>2021-04-03T08:17:58.000Z</published>
    <updated>2021-04-06T14:49:33.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Multilabel classification for exploiting cross-resistance information in HIV-1 drug resistance prediction</p><p>杂志：Bioinformatics (Sequence Analysis)</p><p>IF: 5.610 (2019)</p><p>时间：June 21, 2013</p><p>链接：doi:10.1093/bioinformatics/btt331</p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>多标签分类算法</p><a id="more"></a><h2 id="文章介绍"><a href="#文章介绍" class="headerlink" title="文章介绍"></a>文章介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>耐药性是疾病治疗中面临的一个重要难题。很多细菌或病毒还经常出现交叉耐药现象。不仅导致了当前治疗大的某一药物产生耐药性，而且对未使用的药物也产生耐药性。因此，耐药性的自动分类和预测在临床研究上具有重要的意义。而机器学习虽然已广泛用于抗药性研究，但是多重交叉耐药的信息还有待研究。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p><img src="/2021/04/03/f1069cae/image-20210406163704225.png" alt="image-20210406163704225" style="zoom:50%;"></p><p>IC50 ratio: 这里与药物的抗性相关，IC50 ratio cutoff是每个药物定义为抗性的临界值。</p><h4 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h4><h4 id="分类器链（Classification-Chains-CC）"><a href="#分类器链（Classification-Chains-CC）" class="headerlink" title="分类器链（Classification Chains, CC）"></a>分类器链（Classification Chains, CC）</h4><h4 id="CC的组合"><a href="#CC的组合" class="headerlink" title="CC的组合"></a>CC的组合</h4><h3 id="结果和结论"><a href="#结果和结论" class="headerlink" title="结果和结论"></a>结果和结论</h3><p>（简要，理顺逻辑）</p><h3 id="创新性和意义"><a href="#创新性和意义" class="headerlink" title="创新性和意义"></a>创新性和意义</h3><p>（思路，方法或者数据资源对自己有什么启示）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：Multilabel classification for exploiting cross-resistance information in HIV-1 drug resistance prediction&lt;/p&gt;
&lt;p&gt;杂志：Bioinformatics (Sequence Analysis)&lt;/p&gt;
&lt;p&gt;IF: 5.610 (2019)&lt;/p&gt;
&lt;p&gt;时间：June 21, 2013&lt;/p&gt;
&lt;p&gt;链接：doi:10.1093/bioinformatics/btt331&lt;/p&gt;
&lt;h2 id=&quot;一句话评价&quot;&gt;&lt;a href=&quot;#一句话评价&quot; class=&quot;headerlink&quot; title=&quot;一句话评价&quot;&gt;&lt;/a&gt;一句话评价&lt;/h2&gt;&lt;p&gt;多标签分类算法&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="AMR" scheme="http://yoursite.com/tags/AMR/"/>
    
      <category term="multi-label classification" scheme="http://yoursite.com/tags/multi-label-classification/"/>
    
  </entry>
  
  <entry>
    <title>机器学习在药物抗性分析中的应用</title>
    <link href="http://yoursite.com/2021/04/02/9fe5283f.html"/>
    <id>http://yoursite.com/2021/04/02/9fe5283f.html</id>
    <published>2021-04-02T21:44:14.000Z</published>
    <updated>2021-04-06T11:31:21.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Application of machine learning techniques to tuberculosis drug resistance analysis</p><p>杂志：Bioinformatics, Data and text mining</p><p>IF: 5.610 (2019)</p><p>时间：21 November, 2018</p><p>链接：doi: 10.1093/bioinformatics/bty949</p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>对比了不同的机器学习算法（LR，gradient tree boosting）在预测肺结核药物抗性中的性能</p><a id="more"></a><h2 id="文章介绍"><a href="#文章介绍" class="headerlink" title="文章介绍"></a>文章介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>及时识别结核分枝杆菌（MTB）对现有药物的耐药性对降低死亡率和防止现有抗生素耐药性的扩大至关重要。机器学习方法已被广泛应用于及时预测特定药物下MTB的耐药性和识别耐药标志物。然而，它们在耐药性预测和耐药性标志物识别方面还没有在全球多中心的MTB样本大队列上得到验证。</li><li>本文收集的样本来自6个大洲中的16个国家，共有13402个isolates，涉及到11种药物。</li><li>对比的机器学习方法有：SVM, LR, product-of-marginals (PM), gradient tree boosting, Adaboost, RF。其中LR和gradient tree boosting的性能比其他的算法好。</li><li>此外，根据突变位点的排序提供了一些潜在的研究靶标。并给出了文中所用的源码： <a href="http://www.robots.ox.ac.uk/davidc/code.php" target="_blank" rel="noopener">http://www.robots.ox.ac.uk/davidc/code.php</a></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="/2021/04/02/9fe5283f/image-20210405120750554.png" alt="image-20210405120750554" style="zoom:50%;"></p><h4 id="WGS数据分析"><a href="#WGS数据分析" class="headerlink" title="WGS数据分析"></a>WGS数据分析</h4><p>序列比对，call变异位点，过滤低质量的变异位点，最终保留5919个位点。</p><h4 id="Baseline-Methods"><a href="#Baseline-Methods" class="headerlink" title="Baseline Methods"></a>Baseline Methods</h4><p>现有的基线方法是根据一些预先确定的变异库将药物分类为存在耐药性或不存在耐药性。直接关联(DA)的方法使用 “OR “规则来分类一个分离株对特定药物的抗药性：如果分离株的任何突变都是抗药性变异，则被标记为抗药性。否则，如果分离物中只有易感变异存在，则被归为易感。</p><p>变异库参考：Whole-genome sequencing for prediction of Mycobacterium tuberculosis drug susceptibility and resistance: a retrospective cohort study. Lancet Infect. Dis</p><ul><li><a href="https://pubmed.ncbi.nlm.nih.gov/26116186/" target="_blank" rel="noopener">https://pubmed.ncbi.nlm.nih.gov/26116186/</a></li></ul><h4 id="线性降维"><a href="#线性降维" class="headerlink" title="线性降维"></a>线性降维</h4><p>使用PCA对特征（变异位点）进行降维</p><h4 id="分类器方法"><a href="#分类器方法" class="headerlink" title="分类器方法"></a>分类器方法</h4><p>SVM, LR, product-of-marginals (PM), gradient tree boosting, Adaboost, RF</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="结果和结论"><a href="#结果和结论" class="headerlink" title="结果和结论"></a>结果和结论</h3><h4 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h4><ul><li>总分离株（isolates）的数量：13402</li><li>变异位点：是与之前鉴定到的23个抗性基因相关的位点，共有5919个位点</li><li>11个药物的标签信息（Resistant/Susceptible）, 标签信息不平衡，所有11种药物的易感性分离株均大大高于耐药性分离株。</li></ul><p><img src="/2021/04/02/9fe5283f/image-20210405110521290.png" alt="image-20210405110521290" style="zoom:50%;"></p><h4 id="特征空间（Feature-Spaces）"><a href="#特征空间（Feature-Spaces）" class="headerlink" title="特征空间（Feature Spaces）"></a>特征空间（Feature Spaces）</h4><p>为了评估不同分类器的性能，文中考虑了三个特征集。1） F1是基线特征空间，即在23个候选基因内发现的所有变异。2） F2是根据另一篇文章（<a href="https://pubmed.ncbi.nlm.nih.gov/26116186/）中列出的预定抗药性相关变异。3）" target="_blank" rel="noopener">https://pubmed.ncbi.nlm.nih.gov/26116186/）中列出的预定抗药性相关变异。3）</a> F3是F1的子集，仅包括特定药物的抗药性相关基因（每种药物特有的抗药性决定因素基因，也是根据之前的一篇文章（<a href="https://pubmed.ncbi.nlm.nih.gov/26116186/）。" target="_blank" rel="noopener">https://pubmed.ncbi.nlm.nih.gov/26116186/）。</a></p><h4 id="训练和测试"><a href="#训练和测试" class="headerlink" title="训练和测试"></a>训练和测试</h4><p>分类模型是通过训练一个平衡的训练数据集，然后在不平衡的数据集上进行测试来执行的。并运行超过100次的5-kfold的交叉验证。在每个fold, 选取20%数据作为测试集，剩余的80%的训练集，将易感样本随机分选，使耐药和易感样本的数量相等，然后拆分训练集和验证集（80%:20%）。</p><p>模型评估参数： accuracy, sensitivity, spe- cificity, F1-score 和ROC curve的 area under curve (AUC) </p><h4 id="分类结果"><a href="#分类结果" class="headerlink" title="分类结果"></a>分类结果</h4><p><img src="/2021/04/02/9fe5283f/image-20210405112431592.png" alt="image-20210405112431592" style="zoom:50%;"></p><p><img src="/2021/04/02/9fe5283f/image-20210405112659308.png" alt="image-20210405112659308" style="zoom:50%;"></p><h4 id="突变排序"><a href="#突变排序" class="headerlink" title="突变排序"></a>突变排序</h4><p>选取性能最好的模型，然后提取前10个对每个药物有特有抗性的features。</p><p><img src="/2021/04/02/9fe5283f/image-20210405113331833.png" alt="image-20210405113331833" style="zoom:50%;"></p><h3 id="创新性和意义"><a href="#创新性和意义" class="headerlink" title="创新性和意义"></a>创新性和意义</h3><ul><li>样本量大，最后提供了药物相关的一些潜在靶标</li><li>文章思路：首先是WGS变异分析，然后选取之前研究的25个抗性基因相关的变异位点，再通过降维方法进一步减小特征的维度，最后比较不同的模型对不同组合提取的特征数据集的性能，并通过特征选择给出了每种药物特有的潜在变异位点。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：Application of machine learning techniques to tuberculosis drug resistance analysis&lt;/p&gt;
&lt;p&gt;杂志：Bioinformatics, Data and text mining&lt;/p&gt;
&lt;p&gt;IF: 5.610 (2019)&lt;/p&gt;
&lt;p&gt;时间：21 November, 2018&lt;/p&gt;
&lt;p&gt;链接：doi: 10.1093/bioinformatics/bty949&lt;/p&gt;
&lt;h2 id=&quot;一句话评价&quot;&gt;&lt;a href=&quot;#一句话评价&quot; class=&quot;headerlink&quot; title=&quot;一句话评价&quot;&gt;&lt;/a&gt;一句话评价&lt;/h2&gt;&lt;p&gt;对比了不同的机器学习算法（LR，gradient tree boosting）在预测肺结核药物抗性中的性能&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="AMR" scheme="http://yoursite.com/tags/AMR/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习提高抗生肽的识别</title>
    <link href="http://yoursite.com/2021/04/01/fff0078d.html"/>
    <id>http://yoursite.com/2021/04/01/fff0078d.html</id>
    <published>2021-04-01T15:25:04.000Z</published>
    <updated>2021-04-04T21:53:39.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>题目：Deep learning improves antimicrobial peptide recognition</p><p>杂志：Bioinformatics</p><p>IF: 5.610 (2019)</p><p>时间：24 march, 2018</p><p>链接：doi: 10.1093/bioinformatics/bty179</p><h2 id="一句话评价"><a href="#一句话评价" class="headerlink" title="一句话评价"></a>一句话评价</h2><p>通过卷积网络层和循环神经网络层组合构建的深度学习模型识别抗生肽。</p><a id="more"></a><h2 id="文章介绍"><a href="#文章介绍" class="headerlink" title="文章介绍"></a>文章介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>细菌对抗生素药物的抗性越来越引起人们的关注，对经济，生命健康和社会造成重要的挑战。抗生肽（Antimicrobial peptides ，AMPs）是天然免疫的组成部分，也是研发药物广泛使用的靶点。机器学习的方法可以为湿实验的研究者提供一些潜在的研究位点。</li><li>这篇文章使用卷积网络层和循环神经网络层组成的神经网络模型识别抗菌活动。最终训练的模型也比一般的方法表现更好。此外，通过潜入权重(Embedding Weights)，他们提出了reduced-alphabet representation的方法，最终实现可以只用9个氨基酸分子准确识别AMP。</li><li>最后，他们也提供了模型和数据相关的网站：Antimicrobial Peptide Scanner vr.2 web server， <a href="http://www.ampscanner.com" target="_blank" rel="noopener">www.ampscanner.com</a></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>APD vr.3 database： <a href="http://aps.unmc.edu/AP，" target="_blank" rel="noopener">http://aps.unmc.edu/AP，</a> 主要是革兰氏阴性和阳性细菌的AMP</li><li>过滤掉长度小于10的氨基酸以及和CD-Hit &gt; 90%的共有的序列，最终使用的AMP有1778个，训练集：712，验证集：354，测试集：712。</li><li>人工构建了non-AMP的序列：Torrent et al., 2011; Xiao et al., 2013<ul><li>Torrent,M. et al. (2011) Connecting peptide physicochemical and antimicro- bial properties by a rational prediction model. PLoS One, 6, e16968.</li><li>Xiao,X. et al. (2013) iAMP-2L: a two-level <strong>multi-label classifier</strong> for identifying antimicrobial peptides and their functional types. Anal. Biochem., 436, 168–177.</li><li>从UniProt下载了肽段序列，并过滤掉包含抗性的序列</li></ul></li></ul><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p><img src="/2021/04/01/fff0078d/fig1.png" style="zoom:50%;"></p><p><strong>基于Keras框架搭建的模型</strong>：</p><ul><li>肽段序列被编码为长度为200的序列，20个氨基酸依次编码为1-20，其余以0填充。</li><li>embedding_vector_length: 128</li><li>卷积层：1D convolution, <code>nb_filter: 64, filter_length: 16, init: normal, strides: 1, border_mode: same, activation: relu</code></li><li>池化层：Maxpooling layer，size=5</li><li>LSTM层：100 units, <code>(unroll: True, stateful: False, dropout: 0.1 and rest default settings)</code></li><li>Dense 层：激活函数：sigmoid</li><li>其他参数：10 epochs， ‘adam’ 优化器， loss: binary_cros- sentropy, metrics: accuracy).</li></ul><p><strong>调参：</strong></p><p>Hyperas wrapper package for Keras：<a href="https://github.com/maxpumperla/hyperas" target="_blank" rel="noopener">https://github.com/maxpumperla/hyperas</a> </p><p><strong>模型评估：</strong></p><p>用到评估metrics有：</p><ul><li><p>sensitivity (SENS)</p></li><li><p>specificity (SPEC)</p></li><li><p>ACC </p></li><li><p>Matthews Correlation Coefficient (MCC)</p></li><li><p>ROC curve: pROC package in R</p></li></ul><h3 id="结果和结论"><a href="#结果和结论" class="headerlink" title="结果和结论"></a>结果和结论</h3><p><strong>构建的模型性能：</strong></p><p><img src="/2021/04/01/fff0078d/image-20210404222508046.png" alt="image-20210404222508046" style="zoom:50%;"></p><p><strong>与其他方法的比较</strong></p><p><img src="/2021/04/01/fff0078d/image-20210404222646572.png" alt="image-20210404222646572" style="zoom:50%;"></p><h3 id="创新性和意义"><a href="#创新性和意义" class="headerlink" title="创新性和意义"></a>创新性和意义</h3><ul><li>基于抗生肽识别抗菌性活动</li><li>模型的结构：结合了卷积层和循环神经网络层</li><li>输入数据的处理：embeding layer的处理</li><li>Reduced alphabet model analysis</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章信息&quot;&gt;&lt;a href=&quot;#文章信息&quot; class=&quot;headerlink&quot; title=&quot;文章信息&quot;&gt;&lt;/a&gt;文章信息&lt;/h2&gt;&lt;p&gt;题目：Deep learning improves antimicrobial peptide recognition&lt;/p&gt;
&lt;p&gt;杂志：Bioinformatics&lt;/p&gt;
&lt;p&gt;IF: 5.610 (2019)&lt;/p&gt;
&lt;p&gt;时间：24 march, 2018&lt;/p&gt;
&lt;p&gt;链接：doi: 10.1093/bioinformatics/bty179&lt;/p&gt;
&lt;h2 id=&quot;一句话评价&quot;&gt;&lt;a href=&quot;#一句话评价&quot; class=&quot;headerlink&quot; title=&quot;一句话评价&quot;&gt;&lt;/a&gt;一句话评价&lt;/h2&gt;&lt;p&gt;通过卷积网络层和循环神经网络层组合构建的深度学习模型识别抗生肽。&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="CNN" scheme="http://yoursite.com/tags/CNN/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="AMP" scheme="http://yoursite.com/tags/AMP/"/>
    
      <category term="LSTM" scheme="http://yoursite.com/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>基因组变异的理解和分析</title>
    <link href="http://yoursite.com/2020/10/21/e3914e23.html"/>
    <id>http://yoursite.com/2020/10/21/e3914e23.html</id>
    <published>2020-10-21T19:56:05.000Z</published>
    <updated>2020-10-21T21:21:10.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是遗传变异"><a href="#什么是遗传变异" class="headerlink" title="什么是遗传变异"></a>什么是遗传变异</h3><p>遗传变异（genetic variation）是指一个群体中个体之间DNA序列的差异。变异可发生在生殖细胞（即精子和卵子）中，也发生在体细胞(所有其他)中。只有在生殖细胞中产生的变异才能从一个个体遗传给另一个个体，从而影响种群的动态，并最终影响进化。</p><p><strong>突变（Mutation）和重组（Recombination）</strong>是变异的主要来源。</p><h3 id="遗传变异的类型"><a href="#遗传变异的类型" class="headerlink" title="遗传变异的类型"></a>遗传变异的类型</h3><ul><li><p><strong>点突变Single base-pair mutation</strong></p><p>只有一个碱基发生了替换，具体包括Transition和Transversion。Transition指嘌呤(A/G)之间或嘧啶(T/C)之间的替换。Transversion指嘌呤和嘧啶间的替换。</p></li><li><p><strong>插入/缺失（Indel）</strong></p><p>主要指在基因组某个位置上发生较短长度的<strong>线性片段</strong>插入或者删除的现象。强调<strong>线性</strong>的原因是，这里的插入和删除是<strong>有前后顺序的</strong>与下述的结构性变异不同。Indel长度通常在50bp以下，更多时候甚至是不超过10bp，这个长度范围内的序列变化可以通过Smith-Waterman 的局部比对算法来<strong>准确</strong>获得，并且也能够在目前短读长的测序数据中较好地检测出来。</p></li><li><p><strong>结构变异</strong></p><p>通常就是指基因组上大长度的序列变化和位置关系变化。类型很多，包括长度在50bp以上的长片段序列插入或者删除（Big Indel）、串联重复（Tandem repeate）、染色体倒位（Inversion）、染色体内部或染色体之间的序列易位（Translocation）、拷贝数变异（CNV）以及形式更为复杂的嵌合性变异。1Kb与3Mb之间的序列，包括插入、缺失、拷贝数变异、倒位和易位。</p></li></ul><a id="more"></a><h3 id="变异的鉴定和分析"><a href="#变异的鉴定和分析" class="headerlink" title="变异的鉴定和分析"></a>变异的鉴定和分析</h3><p>变异的鉴定主要分为两个步骤：<strong>比对和variants calling</strong></p><ul><li><p><strong>比对</strong></p><p>​    常用的软件有：BWA，Bowtie2。将质控后的数据(fastq)比对到参考基因组上，得到比对后的reads（bam或CRAM格式）。</p></li><li><p><strong>variants calling</strong></p><p>常用的软件有GATK, bcftools, FreeBays等，这里的variants通常只包含SNPs和Indels，最终得到vcf格式的文件。</p></li></ul><p><img src="/2020/10/21/e3914e23/image-20201021223957905.png" alt="image-20201021223957905"></p><ul><li><p><strong>vcf文件格式介绍</strong></p><p>vcf是<strong>Variant Call Format</strong>的简称，即是变异文件储存的标准格式。下图是E.coli 变异分析的vcf文件示例。</p><ul><li>CHROM： 染色体，由于E.coli是一个环形的基因组，这里没有区分染色体</li><li>POS: 变异位点</li><li>REF: 参考基因组位点的碱基</li><li>ALT：个体变异位点的碱基</li><li>QUAL：质量</li><li>FILTER：如果使用GATK过滤后，会对通过过滤的变异位点有PASS的标签</li><li>INFO: 这一栏包含的信息较多，其中<ul><li>DP：表示覆盖在这个位点的总reads数，也就是这个位点的测序深度</li><li>GT: 表示genotype，通常用”/” or “|”分隔两个数字，“|”phase过也就是杂合的两个等位基因知道哪个等位基因来自哪条染色体；0代表参考基因组的碱基类型；1代表ALT碱基类型的第一个碱基（多个碱基用”,”分隔），2代表ALT第二个碱基，以此类推；比如 REF列为：A， ALT列为G,T；那么0/1基因型为AG 杂合，1/1基因型为GG纯合SNP；1/2代表GT基因型；./.表示缺失。</li></ul></li></ul></li></ul><p><img src="/2020/10/21/e3914e23/image-20201021225018928.png" alt="image-20201021225018928" style="zoom:50%;"></p><h3 id="变异分析常用的工具：bcftools-amp-vcftools"><a href="#变异分析常用的工具：bcftools-amp-vcftools" class="headerlink" title="变异分析常用的工具：bcftools &amp; vcftools"></a>变异分析常用的工具：bcftools &amp; vcftools</h3><h4 id="bcftools的部分功能介绍"><a href="#bcftools的部分功能介绍" class="headerlink" title="bcftools的部分功能介绍"></a>bcftools的部分功能介绍</h4><ul><li><p>Calling Variants</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools mpileup -f REF.fa sample.sorted.bam | bcftools call -vm -Oz &gt; sample.vcf.gz</span><br></pre></td></tr></table></figure></li><li><p>提取等位基因和基因型信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools query -f '%CHROM %POS %REF %ALT [%TGT]\n' query.vcf.gz -o query.extract.txt</span><br></pre></td></tr></table></figure></li></ul><ul><li>变异位点的基本统计分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcftools stats sample.vcf &gt; sample.vcf.stats</span><br><span class="line">plot-vcfstats sample.vcf.stats -p sample.vcf.stats.plot_output</span><br></pre></td></tr></table></figure><p><img src="/2020/10/21/e3914e23/image-20201021231029324.png" alt="image-20201021231029324" style="zoom:50%;"></p><p><img src="/2020/10/21/e3914e23/image-20201021231018278.png" alt="image-20201021231018278" style="zoom:50%;"></p><h4 id="vcftools的部分功能介绍"><a href="#vcftools的部分功能介绍" class="headerlink" title="vcftools的部分功能介绍"></a>vcftools的部分功能介绍</h4><ul><li><p>vcf文件的过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf sample.vcf --minDP 4 --max-missing 0.2 --minQ 30 --recode --recode-INFO-all --out filter</span><br></pre></td></tr></table></figure><p><code>max-missing 0.5</code>: 过滤低于50％的基因型</p><p><code>--minDP 4</code>:过滤depth低于4的reads<br><code>--recode</code>: 标志告诉程序使用过滤器写入一个新的vcf文件，<code>--recode-INFO-all</code>保留旧vcf文件中的所有INFO标志。</p><p><code>--out</code> 输出的文件名称的前缀</p></li><li><p>拆分SNPs和Indels</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 保留SNPs</span></span></span><br><span class="line">vcftools --vcf filter.recode.vcf --remove-indels --recode --recode-INFO-all --out filter.snps </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 保留Indels</span></span></span><br><span class="line">vcftools --vcf filter.recode.vcf --keep-only-indels --recode --recode-INFO-all --out filter.indels</span><br></pre></td></tr></table></figure></li></ul><p>###参考</p><ul><li><a href="https://www.ebi.ac.uk/training-beta/online/courses/human-genetic-variation-introduction/what-is-genetic-variation/" target="_blank" rel="noopener">Human Genetic Variation</a></li><li><a href="https://www.omicsclass.com/article/6" target="_blank" rel="noopener">看懂变异记录结果文件（VCF）</a></li><li><a href="https://www.jianshu.com/p/957efb50108f" target="_blank" rel="noopener">VCF格式</a></li><li><a href="https://luansheng.netlify.app/2019/08/29/how-to-use-bcftools/" target="_blank" rel="noopener">bcftools使用笔记</a></li><li>vcftools: <a href="http://vcftools.sourceforge.net/man_latest.html" target="_blank" rel="noopener">http://vcftools.sourceforge.net/man_latest.html</a></li><li>bcftools: <a href="http://samtools.github.io/bcftools/bcftools.html" target="_blank" rel="noopener">http://samtools.github.io/bcftools/bcftools.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是遗传变异&quot;&gt;&lt;a href=&quot;#什么是遗传变异&quot; class=&quot;headerlink&quot; title=&quot;什么是遗传变异&quot;&gt;&lt;/a&gt;什么是遗传变异&lt;/h3&gt;&lt;p&gt;遗传变异（genetic variation）是指一个群体中个体之间DNA序列的差异。变异可发生在生殖细胞（即精子和卵子）中，也发生在体细胞(所有其他)中。只有在生殖细胞中产生的变异才能从一个个体遗传给另一个个体，从而影响种群的动态，并最终影响进化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;突变（Mutation）和重组（Recombination）&lt;/strong&gt;是变异的主要来源。&lt;/p&gt;
&lt;h3 id=&quot;遗传变异的类型&quot;&gt;&lt;a href=&quot;#遗传变异的类型&quot; class=&quot;headerlink&quot; title=&quot;遗传变异的类型&quot;&gt;&lt;/a&gt;遗传变异的类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;点突变Single base-pair mutation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有一个碱基发生了替换，具体包括Transition和Transversion。Transition指嘌呤(A/G)之间或嘧啶(T/C)之间的替换。Transversion指嘌呤和嘧啶间的替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;插入/缺失（Indel）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要指在基因组某个位置上发生较短长度的&lt;strong&gt;线性片段&lt;/strong&gt;插入或者删除的现象。强调&lt;strong&gt;线性&lt;/strong&gt;的原因是，这里的插入和删除是&lt;strong&gt;有前后顺序的&lt;/strong&gt;与下述的结构性变异不同。Indel长度通常在50bp以下，更多时候甚至是不超过10bp，这个长度范围内的序列变化可以通过Smith-Waterman 的局部比对算法来&lt;strong&gt;准确&lt;/strong&gt;获得，并且也能够在目前短读长的测序数据中较好地检测出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;结构变异&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常就是指基因组上大长度的序列变化和位置关系变化。类型很多，包括长度在50bp以上的长片段序列插入或者删除（Big Indel）、串联重复（Tandem repeate）、染色体倒位（Inversion）、染色体内部或染色体之间的序列易位（Translocation）、拷贝数变异（CNV）以及形式更为复杂的嵌合性变异。1Kb与3Mb之间的序列，包括插入、缺失、拷贝数变异、倒位和易位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data Sciences" scheme="http://yoursite.com/categories/Data-Sciences/"/>
    
    
      <category term="software" scheme="http://yoursite.com/tags/software/"/>
    
      <category term="Genome Variants" scheme="http://yoursite.com/tags/Genome-Variants/"/>
    
  </entry>
  
  <entry>
    <title>python实现的一些数据预处理</title>
    <link href="http://yoursite.com/2020/09/12/2d57b01f.html"/>
    <id>http://yoursite.com/2020/09/12/2d57b01f.html</id>
    <published>2020-09-12T19:35:02.000Z</published>
    <updated>2020-09-12T21:09:41.639Z</updated>
    
    <content type="html"><![CDATA[<p>利用python进行数据分析和计算时，经常用到两种数据类型：数据框(DataFrame)和数组（array)。两种数据类型的转换、多个数据的合并以及计算数据中的最值等问题是频率较高的操作。下面介绍解决这些问题的方法。</p><p>首先导入python中最常用的数据处理两个模块：numpy模块、pandas模块。然后创建一个DataFrame类型数据df，两个数组arr1和arr2。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'A'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'B'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="string">'C'</span>:[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]&#125;)</span><br><span class="line">arr1= np.array([[<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>], [<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>], [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>]])</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="1-DataFrame转换为array"><a href="#1-DataFrame转换为array" class="headerlink" title="(1) DataFrame转换为array"></a>(1) DataFrame转换为array</h4><ul><li>使用DataFrame中的values方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   A  B  C</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(df)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; df_arr = df.values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_arr</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(df_arr)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用Numpy中的array方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_arr2 = np.array(df)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df_arr2</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(df_arr2)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-array转换为Data-Frame"><a href="#2-array转换为Data-Frame" class="headerlink" title="(2) array转换为Data Frame"></a>(2) array转换为Data Frame</h4><p>使用Pandas 的DataFrame方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = pd.DataFrame(df_arr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(df2)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据合并、拼接"><a href="#数据合并、拼接" class="headerlink" title="数据合并、拼接"></a>数据合并、拼接</h3><p>数据合并常见的情况有两个数据框或数组进行水平或垂直方向的合并。</p><h4 id="（1）-DataFrame的合并"><a href="#（1）-DataFrame的合并" class="headerlink" title="（1） DataFrame的合并"></a>（1） DataFrame的合并</h4><p>方法有：</p><ul><li>pandas的<strong>merge函数</strong></li></ul><p><code>df = pd.merge(df1, df2, how=&#39;left&#39;, on=&#39;id&#39;)</code></p><p><code>how=&#39;left&#39;</code>  表示以df1为基准数据，<code>on=&#39;id&#39;</code>表示合并时的索引ID</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">   A  B  C</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">   A   D   E</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">40</span>  <span class="number">70</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">50</span>  <span class="number">80</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">60</span>  <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df3 = pd.merge(df1, df2, how=<span class="string">'left'</span>, on=<span class="string">'A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df3</span><br><span class="line">   A  B  C   D   E</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span>  <span class="number">40</span>  <span class="number">70</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">50</span>  <span class="number">80</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  <span class="number">60</span>  <span class="number">90</span></span><br></pre></td></tr></table></figure><ul><li>pandas的<strong>concat函数</strong></li></ul><p><code>df = pd.concat(df1,df2, axis )</code>, axis=1表示列拼接，axis=0表示行拼接</p><p>只是简单的只进行数据拼接，并不进行去除差异或相似的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df4 = pd.concat([df1,df2],axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df4</span><br><span class="line">   A    B    C     D     E</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4.0</span>  <span class="number">7.0</span>   NaN   NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5.0</span>  <span class="number">8.0</span>   NaN   NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6.0</span>  <span class="number">9.0</span>   NaN   NaN</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  NaN  NaN  <span class="number">40.0</span>  <span class="number">70.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  NaN  NaN  <span class="number">50.0</span>  <span class="number">80.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  NaN  NaN  <span class="number">60.0</span>  <span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df5 = pd.concat([df1,df2],axis=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df5</span><br><span class="line">   A  B  C  A   D   E</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span>  <span class="number">1</span>  <span class="number">40</span>  <span class="number">70</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">50</span>  <span class="number">80</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  <span class="number">3</span>  <span class="number">60</span>  <span class="number">90</span></span><br></pre></td></tr></table></figure><h4 id="2-Array的合并"><a href="#2-Array的合并" class="headerlink" title="(2) Array的合并"></a>(2) Array的合并</h4><p>方法包括以下几种，常见的有concatenate, stack,hstack和vastack</p><p><img src="/2020/09/12/2d57b01f/image-20200912224933250.png" alt="image-20200912224933250"></p><p><strong>原始数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1= np.array([[<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>], [<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2 = np.array([[<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>], [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1</span><br><span class="line">array([[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2</span><br><span class="line">array([[<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">       [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(arr1)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(arr2)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr1</span>.<span class="title">shape</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr2</span>.<span class="title">shape</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>concatenate</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; arr3=np.concatenate((arr1, arr2)) # 默认axis=0，行方向合并</span><br><span class="line">&gt;&gt;&gt; arr3</span><br><span class="line">array([[21, 22, 23],</span><br><span class="line">       [24, 25, 26],</span><br><span class="line">       [27, 28, 29],</span><br><span class="line">       [31, 32, 33]])</span><br><span class="line">&gt;&gt;&gt; arr3.shape</span><br><span class="line">(4, 3)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; arr4=np.concatenate((arr1, arr2),axis=1)</span><br><span class="line">&gt;&gt;&gt; arr4</span><br><span class="line">array([[21, 22, 23, 27, 28, 29],</span><br><span class="line">       [24, 25, 26, 31, 32, 33]])</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>stack</strong></li></ul><p><code>np.stack(())</code>合并后的数据是多个数组，纬度增加。参数axis默认值为0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr5 = np.stack((arr1, arr2))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr5</span><br><span class="line">array([[[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr5.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr6 = np.stack((arr1, arr2),axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr6</span><br><span class="line">array([[[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr6.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr7 = np.stack((arr1, arr2),axis=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr7</span><br><span class="line">array([[[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]]])</span><br></pre></td></tr></table></figure><ul><li><strong>hstack</strong>：水平合并, 数组纬度没变</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((arr1,arr2))</span><br><span class="line">array([[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]])</span><br></pre></td></tr></table></figure><ul><li><strong>vstack</strong>：垂直合并，数组纬度没变</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.vstack((arr1,arr2))</span><br><span class="line">array([[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">       [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">       [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>]])</span><br></pre></td></tr></table></figure><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><p>使用numpy的max/min函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1</span><br><span class="line">array([[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.max(arr1)</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.max(arr1,axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.max(arr1,axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">23</span>, <span class="number">26</span>])</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/guofei_fly/article/details/85485173?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Numpy中的数组拼接、合并操作</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用python进行数据分析和计算时，经常用到两种数据类型：数据框(DataFrame)和数组（array)。两种数据类型的转换、多个数据的合并以及计算数据中的最值等问题是频率较高的操作。下面介绍解决这些问题的方法。&lt;/p&gt;
&lt;p&gt;首先导入python中最常用的数据处理两个模块：numpy模块、pandas模块。然后创建一个DataFrame类型数据df，两个数组arr1和arr2。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Sciences" scheme="http://yoursite.com/categories/Data-Sciences/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="data preprocessing" scheme="http://yoursite.com/tags/data-preprocessing/"/>
    
  </entry>
  
  <entry>
    <title>两个文件的异同</title>
    <link href="http://yoursite.com/2020/06/28/13171.html"/>
    <id>http://yoursite.com/2020/06/28/13171.html</id>
    <published>2020-06-28T18:15:28.000Z</published>
    <updated>2020-09-12T09:49:57.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="comm-diff-和-grep"><a href="#comm-diff-和-grep" class="headerlink" title="comm, diff 和 grep"></a>comm, diff 和 grep</h3><p>基于comm, diff和grep的用法总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comm A B</span><br><span class="line">diff A B</span><br><span class="line">grep -f A B</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h3><p><strong>comm</strong>是对两个已经<strong>有序</strong>的文件进行比较，可以比较输出：仅在A中出现的、仅在B中出现的、在两个文件中都存在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">comm -1 A B 不显示在A文件中独有内容(显示B文件独有内容+两个文件共有)</span><br><span class="line">comm -2 A B 不显示在B文件中独有内容</span><br><span class="line">comm -3 A B 不显示同时在两个文件中都存在的内容</span><br><span class="line">comm -12 A B 显示A与B公共的部分</span><br><span class="line">comm -23 A B 显示A独有的</span><br><span class="line">comm -13 A B 显示B独有的</span><br></pre></td></tr></table></figure><p><img src="/2020/06/28/13171/fig1.png" alt="image.png" style="zoom:50%;"></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a><strong>diff</strong></h3><p>diff是比较两个文件之间的不同，给出使两个一致的建议，diff有前后顺序，前面的为旧文件，后面的为新文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff A B  直接显示两个文件不同，并给出修改一致的建议(主要是对旧文件的建议)</span><br><span class="line">diff -c A B  通过显示两个文件上下文，给出两个文件增减或删除信息，同时</span><br><span class="line">diff A B</span><br><span class="line">3,4c3,6</span><br><span class="line">&lt; c</span><br><span class="line">&lt; d</span><br><span class="line">---</span><br><span class="line">&gt; e</span><br><span class="line">&gt; f</span><br><span class="line">&gt; g</span><br><span class="line">&gt; h</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep -v -f a b  从b中剔除a中有的,即b中特有的</span><br><span class="line">grep -v -f b a  从a中剔除b中有的,即a中特有的</span><br><span class="line">grep -v -f A B</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">h</span><br><span class="line">grep -v -f  B A</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/5ab86345b6bf" target="_blank" rel="noopener">https://www.jianshu.com/p/5ab86345b6bf</a></p><p><a href="https://blog.csdn.net/hit_hlj_sgy/article/details/20625527" target="_blank" rel="noopener">https://blog.csdn.net/hit_hlj_sgy/article/details/20625527</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;comm-diff-和-grep&quot;&gt;&lt;a href=&quot;#comm-diff-和-grep&quot; class=&quot;headerlink&quot; title=&quot;comm, diff 和 grep&quot;&gt;&lt;/a&gt;comm, diff 和 grep&lt;/h3&gt;&lt;p&gt;基于comm, diff和grep的用法总结&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;comm A B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff A B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;grep -f A B&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="text processing" scheme="http://yoursite.com/tags/text-processing/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell 字符穿操作</title>
    <link href="http://yoursite.com/2020/06/28/17442.html"/>
    <id>http://yoursite.com/2020/06/28/17442.html</id>
    <published>2020-06-28T18:15:10.000Z</published>
    <updated>2020-09-12T09:49:57.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word=abcd-//master-01://httpab</span><br></pre></td></tr></table></figure><h4 id="从左向右"><a href="#从左向右" class="headerlink" title="从左向右:"></a>从左向右:</h4><p><strong>截取第一个//后的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word#*//&#125;</span><br><span class="line"># master-01://httpab</span><br></pre></td></tr></table></figure><p><strong>截取最后一个//后的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word##*//&#125; </span><br><span class="line">httpab</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="从右向左"><a href="#从右向左" class="headerlink" title="从右向左: %"></a>从右向左: %</h4><p><strong>截取第一个//后的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word%//*&#125; </span><br><span class="line">abcd-//master-01:</span><br></pre></td></tr></table></figure><p><strong>截取第二个//后的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word%%//*&#125; </span><br><span class="line">abcd-</span><br></pre></td></tr></table></figure><h4 id="截取特定序列位置的字符"><a href="#截取特定序列位置的字符" class="headerlink" title="截取特定序列位置的字符"></a>截取特定序列位置的字符</h4><p><strong>前3个字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word:0:3&#125;</span><br></pre></td></tr></table></figure><p><strong>第2到5的字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word:1:4&#125;</span><br><span class="line">bcd-</span><br></pre></td></tr></table></figure><p><strong>从第二个字符到末尾</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word:1&#125;</span><br><span class="line">bcd-//master-01://httpab</span><br></pre></td></tr></table></figure><h3 id="替换-before-after"><a href="#替换-before-after" class="headerlink" title="替换:/before/after"></a>替换:/before/after</h3><h4 id="将第一个ab替换为AB"><a href="#将第一个ab替换为AB" class="headerlink" title="将第一个ab替换为AB"></a>将第一个ab替换为AB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word/#ab/AB&#125; </span><br><span class="line">或 echo $&#123;word/ab/AB&#125; </span><br><span class="line">ABcd-//master-01://httpab</span><br></pre></td></tr></table></figure><h4 id="从左到右，匹配第一个，替换-为cd"><a href="#从左到右，匹配第一个，替换-为cd" class="headerlink" title="从左到右，匹配第一个，替换//为cd"></a>从左到右，匹配第一个，替换//为cd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word/\/\//cd&#125;</span><br><span class="line">abcd-cdmaster-01://httpab</span><br></pre></td></tr></table></figure><h4 id="将所有匹配的-替换为cd"><a href="#将所有匹配的-替换为cd" class="headerlink" title="将所有匹配的//替换为cd"></a>将所有匹配的//替换为cd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;word//\/\//cd&#125;</span><br><span class="line">abcd-cdmaster-01:cdhttpab</span><br></pre></td></tr></table></figure><h4 id="后缀匹配"><a href="#后缀匹配" class="headerlink" title="后缀匹配"></a>后缀匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word=abcd-//master-01://httpab</span><br><span class="line">echo $&#123;word/%http*/xy&#125; </span><br><span class="line"># 输出:abcd-//master-01://xy</span><br><span class="line">echo $&#123;word/%ab/xy&#125;</span><br><span class="line"># 输出:abcd-//master-01://httpxy</span><br><span class="line">echo $&#123;word/%ab*/xy&#125;</span><br><span class="line"># 出现*，会从起始匹配</span><br><span class="line"># 输出:xy</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 删除前3个字符</span><br><span class="line">echo $&#123;word#*$&#123;word:0:3&#125;&#125; </span><br><span class="line"># 删除后3个字符</span><br><span class="line">echo $&#123;word%*$&#123;word:(-3)&#125;&#125;</span><br><span class="line"># 删除第一个ab</span><br><span class="line">echo $&#123;word/ab/&#125; </span><br><span class="line">删除所有ab</span><br><span class="line">echo $&#123;word//ab/&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_23091073/article/details/83066518" target="_blank" rel="noopener">https://blog.csdn.net/qq_23091073/article/details/83066518</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;截取&quot;&gt;&lt;a href=&quot;#截取&quot; class=&quot;headerlink&quot; title=&quot;截取&quot;&gt;&lt;/a&gt;截取&lt;/h3&gt;&lt;h4 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;word=abcd-//master-01://httpab&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;从左向右&quot;&gt;&lt;a href=&quot;#从左向右&quot; class=&quot;headerlink&quot; title=&quot;从左向右:&quot;&gt;&lt;/a&gt;从左向右:&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;截取第一个//后的字符串&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo $&amp;#123;word#*//&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# master-01://httpab&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;截取最后一个//后的字符串&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo $&amp;#123;word##*//&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;httpab&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="text processing" scheme="http://yoursite.com/tags/text-processing/"/>
    
  </entry>
  
  <entry>
    <title>不同服务器间以及服务器与本地的文件传输</title>
    <link href="http://yoursite.com/2020/06/28/28636.html"/>
    <id>http://yoursite.com/2020/06/28/28636.html</id>
    <published>2020-06-28T18:14:51.000Z</published>
    <updated>2020-09-12T09:49:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>前提是在同一网络下，可以使用 <code>scp</code> 命令。</p><p>如：</p><h3 id="两服务器间的传输"><a href="#两服务器间的传输" class="headerlink" title="两服务器间的传输"></a>两服务器间的传输</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp user1@server_addess_ip:/file_adderess user2@server2_address_ip</span><br><span class="line">## eg:</span><br><span class="line">scp root@192.168.8.138:/home/ligh/index.php root@192.168.8.139:/root</span><br></pre></td></tr></table></figure><h3 id="服务器和本地间的传输"><a href="#服务器和本地间的传输" class="headerlink" title="服务器和本地间的传输"></a>服务器和本地间的传输</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user1@server_addess_ip:/file_adderess /d</span><br><span class="line"></span><br><span class="line">## eg:</span><br><span class="line">scp root@192.168.8.138:/home/ligh/index.php /d/data</span><br></pre></td></tr></table></figure><h3 id="指定端口非22的传输"><a href="#指定端口非22的传输" class="headerlink" title="指定端口非22的传输"></a>指定端口非22的传输</h3><p>使用  <code>P</code> 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 223  root@192.168.8.13e:/home/strains.tar.gz ./</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前提是在同一网络下，可以使用 &lt;code&gt;scp&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;h3 id=&quot;两服务器间的传输&quot;&gt;&lt;a href=&quot;#两服务器间的传输&quot; class=&quot;headerlink&quot; title=&quot;两服务器间的传输&quot;&gt;&lt;/a&gt;两服务器间的传输&lt;
      
    
    </summary>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Pandas库</title>
    <link href="http://yoursite.com/2020/06/28/45881.html"/>
    <id>http://yoursite.com/2020/06/28/45881.html</id>
    <published>2020-06-28T18:14:01.000Z</published>
    <updated>2020-09-12T09:49:57.627Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas库是基于Numpy库来创建的，Numpy主要用于矩阵操作，而Pandas主要用于数据处理。</p><p>Pandas主要有两种重要的数据结构：Series和DataFrame.</p><ul><li><p>Series: 类似一个一维数组，一个Series对应DataFrame的一列</p></li><li><p>DataFrame:类似一个二维数组，一个DataFrame由几个Series列构成。</p><p><img src="/2020/06/28/45881/fig1.png" style="zoom:50%;"></p></li></ul><p><img src="/2020/06/28/45881/fig1.png" alt="image.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/40373125" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40373125</a></li><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas库是基于Numpy库来创建的，Numpy主要用于矩阵操作，而Pandas主要用于数据处理。&lt;/p&gt;
&lt;p&gt;Pandas主要有两种重要的数据结构：Series和DataFrame.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Series: 类似一个一维数组，一个Series
      
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NumPy介绍</title>
    <link href="http://yoursite.com/2020/06/28/49844.html"/>
    <id>http://yoursite.com/2020/06/28/49844.html</id>
    <published>2020-06-28T18:13:50.000Z</published>
    <updated>2020-09-12T09:49:57.627Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas库是基于Numpy库来创建的，Numpy主要用于矩阵操作，而Pandas主要用于数据处理。</p><p>Pandas主要有两种重要的数据结构：Series和DataFrame.</p><ul><li>Series: 类似一个一维数组，一个Series对应DataFrame的一列</li><li>DataFrame:类似一个二维数组，一个DataFrame由几个Series列构成。</li></ul><a id="more"></a><p><img src="/2020/06/28/49844/1591819950732-0cf02f6a-c25b-4ca1-8876-17dc2e63dd9e-20200628202724030.png" alt="image.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/40373125" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40373125</a></li><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pandas库是基于Numpy库来创建的，Numpy主要用于矩阵操作，而Pandas主要用于数据处理。&lt;/p&gt;
&lt;p&gt;Pandas主要有两种重要的数据结构：Series和DataFrame.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Series: 类似一个一维数组，一个Series对应DataFrame的一列&lt;/li&gt;
&lt;li&gt;DataFrame:类似一个二维数组，一个DataFrame由几个Series列构成。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
