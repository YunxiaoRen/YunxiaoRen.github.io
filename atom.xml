<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生信拾光</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-21T15:01:18.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>六六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SVM从原理到实现</title>
    <link href="http://yoursite.com/2020/04/21/Tue%20Apr%2021%202020%2014:41:09%20GMT+0200/"/>
    <id>http://yoursite.com/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/</id>
    <published>2020-04-21T12:41:09.000Z</published>
    <updated>2020-04-21T15:01:18.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SVM-简介"><a href="#SVM-简介" class="headerlink" title="SVM 简介"></a>SVM 简介</h3><p><strong>SVM(Support Vector Machines)</strong>支持向量机是机器学习中的一种分类算法，属于监督式学习，也可以同时用于分类和回归问题。SVM的核心思想是找到最大的边际超平面，以最大程度地将数据集划分为类。</p><a id="more"></a><h3 id="SVM原理"><a href="#SVM原理" class="headerlink" title="SVM原理"></a>SVM原理</h3><p><strong>术语</strong></p><ul><li><p><strong>Margin</strong></p><p>边距是最接近的分类点上的两条线之间的间隙。 这是从线到支持向量或最接近点的垂直距离来计算的。 如果两个类之间的边距较大，则认为是良好的边距，较小的边距是较差的边距</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig2.png" style="zoom:50%;"></p></li><li><p><strong>Soft Margin</strong></p><p>允许错误分类，这时观测值和阈值间的距离也称作Soft Margin。使用Cross Validation确定在 Soft Margin错误分类的个数，从而得到最好的分类模型。</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig3.png" style="zoom:50%;"></p></li><li><p><strong>支持向量</strong>（Support Vectors)</p><p>支持向量是最靠近超平面的数据点。 这些点将通过计算边距更好地定义分隔线。 这些点与分类器的构建更相关</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig4.png" style="zoom:50%;"></p><p>当处理的数据是一维时，Support Vector Classifier 是一个单独点；当处理的数据是二维时，Support Vector Classifier是一条线(如下图2-D)；当处理的数据是三维时，<strong>Support Vector Classifier 是一个超平面（hyperplane）</strong>(如下图3-D)</p><p>图2-D：</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig5.png" style="zoom: 25%;"></p><p>图3-D：</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig6.png" style="zoom:25%;"></p></li></ul><p><strong>SVM 背后的原理</strong></p><p>首先以低维数据开始</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig7.png" style="zoom:25%;"></p><p>然后将数据转为更高的维度</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig8.png" alt="fig8" style="zoom:25%;"></p><p>找到一个Support Vector Classifier可以将高维数据分为两类</p><p><img src="/2020/04/21/Tue Apr 21 2020 14:41:09 GMT+0200/fig9.png" style="zoom:25%;"></p><p><strong>SVM数学原理</strong></p><p>利用<strong>核函数（Kernel Functions)</strong>找到Support Vector Classifier</p><ul><li><strong>Polynomial Kernel</strong>（多项核）:包含参数d,表示多项式的维度,如d=1,表示1维，d=3,表示3维。</li><li><strong>Radial Kernel</strong>:用于无限维度</li></ul><h3 id="SVM优缺点"><a href="#SVM优缺点" class="headerlink" title="SVM优缺点"></a>SVM优缺点</h3><p><strong>优点：</strong></p><ul><li><strong>High Dimensionality</strong></li><li><strong>Memory Efficiency</strong></li><li><strong>Versatility</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>Kernel Parameters Selection</strong></li><li><strong>Non-Probabilistic</strong></li></ul><h3 id="R和Python中实现SVM"><a href="#R和Python中实现SVM" class="headerlink" title="R和Python中实现SVM"></a>R和Python中实现SVM</h3><p><strong>R中实现SVM</strong></p><p>R中可以借助<strong>package <code>e1071</code></strong>，</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Import Library</span></span><br><span class="line"><span class="keyword">require</span>(e1071) <span class="comment">#Contains the SVM </span></span><br><span class="line">Train &lt;- read.csv(file.choose())</span><br><span class="line">Test &lt;- read.csv(file.choose())</span><br><span class="line"><span class="comment"># there are various options associated with SVM training; like changing kernel, gamma and C value.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">model &lt;- svm(Target~Predictor1+Predictor2+Predictor3,data=Train,kernel=<span class="string">'linear'</span>,gamma=<span class="number">0.2</span>,cost=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Predict Output</span></span><br><span class="line">preds &lt;- predict(model,Test)</span><br><span class="line">table(preds)</span><br><span class="line"></span><br><span class="line">链接：https://www.zhihu.com/question/<span class="number">21094489</span>/answer/<span class="number">392090279</span></span><br></pre></td></tr></table></figure><p>具体参考：<a href="https://www.datacamp.com/community/tutorials/support-vector-machines-r" target="_blank" rel="noopener">https://www.datacamp.com/community/tutorials/support-vector-machines-r</a></p><p><strong>Python中实现SVM</strong></p><p>Python中可以借助scikit-learn库，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Import Library</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="comment">#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset</span></span><br><span class="line"><span class="comment"># Create SVM classification object </span></span><br><span class="line">model = svm.svc(kernel=<span class="string">'linear'</span>, c=<span class="number">1</span>, gamma=<span class="number">1</span>) </span><br><span class="line"><span class="comment"># there is various option associated with it, like changing kernel, gamma and C value. Will discuss more # about it in next section.Train the model using the training sets and check score</span></span><br><span class="line">model.fit(X, y)</span><br><span class="line">model.score(X, y)</span><br><span class="line"><span class="comment">#Predict Output</span></span><br><span class="line">predicted= model.predict(x_test)</span><br><span class="line"></span><br><span class="line">链接：https://www.zhihu.com/question/<span class="number">21094489</span>/answer/<span class="number">392090279</span></span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><p><a href="https://www.youtube.com/watch?v=Qc5IyLW_hns&amp;list=PLblh5JKOoLUICTaGLRoHQDuF_7q2GfuJF&amp;index=51" target="_blank" rel="noopener">Statquest有关SVM视频</a></p></li><li><p><a href="https://www.datacamp.com/community/tutorials/support-vector-machines-r" target="_blank" rel="noopener">Support Vector Machines in R</a></p></li><li><p><a href="https://www.zhihu.com/question/21094489" target="_blank" rel="noopener">支持向量机(SVM)是什么意思</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/31886934" target="_blank" rel="noopener">支持向量机（SVM）——原理篇</a></p></li><li><p><a href="https://www.r-bloggers.com/machine-learning-using-support-vector-machines/" target="_blank" rel="noopener">Machine Learning Using Support Vector Machines</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SVM-简介&quot;&gt;&lt;a href=&quot;#SVM-简介&quot; class=&quot;headerlink&quot; title=&quot;SVM 简介&quot;&gt;&lt;/a&gt;SVM 简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;SVM(Support Vector Machines)&lt;/strong&gt;支持向量机是机器学习中的一种分类算法，属于监督式学习，也可以同时用于分类和回归问题。SVM的核心思想是找到最大的边际超平面，以最大程度地将数据集划分为类。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Sciences" scheme="http://yoursite.com/categories/Data-Sciences/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习在生物医学中的应用</title>
    <link href="http://yoursite.com/2020/04/18/Sat%20Apr%2018%202020%2010:04:07%20GMT+0200/"/>
    <id>http://yoursite.com/2020/04/18/Sat Apr 18 2020 10:04:07 GMT+0200/</id>
    <published>2020-04-18T08:04:07.000Z</published>
    <updated>2020-04-19T20:31:15.378Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章信息</strong></p><p>题目：How Machine Learning Will Transform Biomedicine</p><p>杂志：Cell</p><p>时间：April 2,2020</p><p>链接: <a href="https://doi.org/10.1016/j.cell.2020.03.022" target="_blank" rel="noopener">https://doi.org/10.1016/j.cell.2020.03.022</a></p><p><img src="/2020/04/18/Sat Apr 18 2020 10:04:07 GMT+0200/fig1.png" style="zoom:50%;"></p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>机器学习在语音识别，自动化驾驶汽车，生物医学等领域展现了巨大的潜在应用。机器学习将如何影响生物医学？这篇综述从机器学习对临床诊断、精准治疗和健康监管3个方面进行讨论。介绍了机器学习在这3个领域成功应用的例子，以及面临的机遇和挑战。此外也对机器学习的基本概念有简单的概述。</p><p><strong>机器学习中的基本概念</strong></p><ul><li><p><strong>监督学习、非监督学习和半监督学习</strong></p><p>监督学习在预测数据时是基于含有标签的过去数据；非监督学习是对没有标签数据进行分析学习，如聚类等；半监督学习首先执行无监督学习，然后从无监督学习中基于认为标记发现结构</p></li><li><p><strong>分类和回归</strong></p><p>都是监督学习的方法，分类是预测离散的类别，如正常与患病；而回归预测实际值的输出，如对治疗的反应</p></li><li><p><strong>集成学习</strong></p><p>集成方法建立了许多模型，并使用所有模型的平均值生成预测。常见的集成方法包括随机森林、梯度增强和叠加/元集成</p></li><li><p><strong>深度学习</strong></p><p>能够学习复杂非线性函数的多层人工神经网络。对于非结构化数据（如图像、语音或文本）非常有用，但通常不提供驱动函数的数据方面的细节</p></li><li><p><strong>贝叶斯学习</strong></p><p>结合先验知识和数据来执行机器学习的方法</p></li><li><p><strong>降维</strong></p><p>通过选择重要特征或组合特征来捕获数据集中的差异，减少数据集的属性或特征数。通常用于提高机器学习模型的性能和帮助可视化</p></li><li><p><strong>联合学习</strong></p><p>从分布在多个位置且不能组合成单个数据集的数据中增量学习的方法。当数据位于多个临床系统中或从敏感的个人数据中学习时，联合学习非常有用</p></li></ul><p><img src="/2020/04/18/Sat Apr 18 2020 10:04:07 GMT+0200/fig2.png" style="zoom:50%;"></p><p><strong>机器学习在诊断和治疗中应用例子</strong></p><ul><li><p>The genomic and transcriptomic architecture of 2,000 breast tumours reveals novel subgroups</p><blockquote><p><a href="https://www.nature.com/articles/nature10983" target="_blank" rel="noopener">https://www.nature.com/articles/nature10983</a></p></blockquote></li><li><p>DeepCC: a novel deep learning-based framework for cancer molecular subtype classification</p><blockquote><p><a href="https://www.nature.com/articles/s41389-019-0157-8" target="_blank" rel="noopener">https://www.nature.com/articles/s41389-019-0157-8</a> </p></blockquote></li><li><p>Predicting drug response of tumors from integrated genomic profiles by deep neural networks</p><blockquote><p><a href="https://www.ncbi.nlm.nih.gov/pubmed/30704458" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pubmed/30704458</a></p></blockquote></li><li><p>A community effort to assess and improve drug sensitivity prediction algorithms</p><blockquote><p><a href="https://www.nature.com/articles/nbt.2877" target="_blank" rel="noopener">https://www.nature.com/articles/nbt.2877</a></p></blockquote></li><li><p>A comparison of deep learning performance against health-care professionals in detecting diseases from medical imaging: a systematic review and meta-analysis</p><blockquote><p><a href="https://www.thelancet.com/journals/landig/article/PIIS2589-7500(19)30123-2/fulltext" target="_blank" rel="noopener">https://www.thelancet.com/journals/landig/article/PIIS2589-7500(19)30123-2/fulltext</a></p></blockquote></li><li><p>Prediction of gestational diabetes based on nationwide electronic health records</p><blockquote><p><a href="https://www.ncbi.nlm.nih.gov/pubmed/31932807" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pubmed/31932807</a></p></blockquote></li><li><p>Privacy-Preserving Patient Similarity Learning in a Federated Environment: Development and Analysis</p><blockquote><p><a href="https://www.ncbi.nlm.nih.gov/pubmed/29653917" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pubmed/29653917</a></p></blockquote></li><li><p>Smartwatch Algorithm for Automated Detection of Atrial Fibrillation</p><blockquote><p><a href="https://www.sciencedirect.com/science/article/pii/S0735109718334867?via%3Dihub" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/pii/S0735109718334867?via%3Dihub</a></p></blockquote></li><li><p>Contactless cardiac arrest detection using smart devices</p><blockquote><p><a href="https://www.nature.com/articles/s41746-019-0128-7" target="_blank" rel="noopener">https://www.nature.com/articles/s41746-019-0128-7</a></p></blockquote></li></ul><p><img src="/2020/04/18/Sat Apr 18 2020 10:04:07 GMT+0200/fig3.png" style="zoom:50%;"></p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：How Machine Learning Will Transform Biomedicine&lt;/p&gt;
&lt;p&gt;杂志：Cell&lt;/p&gt;
&lt;p&gt;时间：April 2,2020&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://doi.org/10.1016/j.cell.2020.03.022&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://doi.org/10.1016/j.cell.2020.03.022&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/18/Sat Apr 18 2020 10:04:07 GMT+0200/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>接纳自己的不完美</title>
    <link href="http://yoursite.com/2020/04/12/Sun%20Apr%2012%202020%2023:15:52%20GMT+0200/"/>
    <id>http://yoursite.com/2020/04/12/Sun Apr 12 2020 23:15:52 GMT+0200/</id>
    <published>2020-04-12T21:15:52.000Z</published>
    <updated>2020-04-12T21:18:51.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《心灵捕手 Good Will Hunting 》（1997）</strong></p><p><img src="/2020/04/12/Sun Apr 12 2020 23:15:52 GMT+0200/心灵捕手.png" style="zoom:50%;"></p><p><strong>豆瓣剧情简介</strong></p><blockquote><p>麻省理工学院的数学教授蓝波在席上公布了一道困难的数学题，却被年轻的清洁工威尔（马特·戴蒙 饰）解了出来。可是威尔却是个问题少年，成天和好朋友查克（本·阿弗莱特 饰）等人四处闲逛，打架滋事。当蓝波找到这个天才的时候，他正因为打架袭警被法庭宣判送进看守所。蓝波向法官求情保释，才使他免于牢狱之灾。蓝波为了让威尔找到自己的人生目标，不浪费他的数学天赋，请了很多心理学专家为威尔做辅导，但是威尔十分抗拒，专家们都束手无策。无计可施之下，蓝波求助于他大学的好友，心理学教授尚恩（罗宾·威廉姆斯 饰），希望能够帮助威尔打开心房。经过蓝波和尚恩的不懈努力，威尔渐渐敞开心胸，而好友查克的一席话，更是让他豁然开朗。</p></blockquote><p>这部电影从表面上可以归类为心里咨询与教育的影片，我更喜欢这部电影映射出的人与人之间相处与交流的原则：彼此坦诚，才可以赢得信任，进而走进对方的内心。以及每个人应该学会与内心的自己相处，正面认识自己，接纳自己的不完美。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;《心灵捕手 Good Will Hunting 》（1997）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/12/Sun Apr 12 2020 23:15:52 GMT+0200/心灵捕手.png&quot; style=&quot;zoom:50%
      
    
    </summary>
    
    
      <category term="影评" scheme="http://yoursite.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>基于微生物组学数据的深度表征学习预测疾病</title>
    <link href="http://yoursite.com/2020/04/12/Sun%20Apr%2012%202020%2021:36:46%20GMT+0200/"/>
    <id>http://yoursite.com/2020/04/12/Sun Apr 12 2020 21:36:46 GMT+0200/</id>
    <published>2020-04-12T19:36:46.000Z</published>
    <updated>2020-04-12T20:02:10.428Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p>深度表征学习在疾病预测中的应用</p><p><strong>文章信息</strong></p><p>题目：DeepMicro: deep representation learning for disease prediction based on microbiome data</p><p>杂志：Scientific Reports</p><p>时间：7 April, 2020</p><p>链接: <a href="https://www.nature.com/articles/s41598-020-63159-5" target="_blank" rel="noopener">https://www.nature.com/articles/s41598-020-63159-5</a></p><p><strong>figure</strong></p><p><img src="/2020/04/12/Sun Apr 12 2020 21:36:46 GMT+0200/fig1.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章介绍：</strong></p><p>微生物组学数据在人类健康和疾病领域中扮演着重要的作用，然而，微生物组学数据的高纬性，以及样本量低等特点使基于机器学习的预测算法面临极大的挑战。这篇文章基于深度表征学习框架，提出了DeepMicro的方法，可使用各种自动编码器成功的将高维数据转换为低维表示，加快了模型训练和超参数优化过程，在基本方法的基础上提高了8-30倍。在5个不同的数据集上的测试显示DeepMicro在疾病预测方面潜在应用。</p><p>DeepMicro的实现环境和使用的工具包有：</p><ul><li>Python 3.5.2</li><li>Numpy 1.16.2, </li><li>Pandas 0.24.2, </li><li>Scipy 1.2.1, </li><li>Scikt-learn 0.20.3, </li><li>Keras 2.2.4</li><li>Tensorflow 1.13.1</li></ul><p>代码：<a href="https://github.com/minoh0201/DeepMicro" target="_blank" rel="noopener">https://github.com/minoh0201/DeepMicro</a></p><blockquote><p><strong>表征学习（representation learning）</strong></p><p>机器学习算法的成功与否不仅仅取决于算法本身，也取决于数据的表示。数据的不同表示可能会导致有效信息的隐藏或是曝露，这也决定了算法是不是能直截了当地解决问题。表征学习的目的是对复杂的原始数据化繁为简，把原始数据的无效信息剔除，把有效信息更有效地进行提炼，形成特征，这也应和了机器学习的一大任务——可解释性。 也正是因为特征的有效提取，使得今后的机器学习任务简单并且精确许多。在我们接触机器学习、深度学习之初，我们就知道有一类任务也是提炼数据的，那就是特征工程。与表征学习不同的是，特征工程是人为地处理数据，也是我们常听的“洗数据”。 而表示学习是借助算法让机器自动地学习有用的数据和其特征。 不过这两个思路都在尝试解决机器学习的一个主要问题——如何更合理高效地将特征表示出来。</p><p>链接：<a href="https://www.zhihu.com/question/37162929" target="_blank" rel="noopener">https://www.zhihu.com/question/37162929</a><br>来源：知乎</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深度表征学习在疾病预测中的应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：DeepMicro: deep representation learning for disease prediction based on microbiome data&lt;/p&gt;
&lt;p&gt;杂志：Scientific Reports&lt;/p&gt;
&lt;p&gt;时间：7 April, 2020&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://www.nature.com/articles/s41598-020-63159-5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nature.com/articles/s41598-020-63159-5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/12/Sun Apr 12 2020 21:36:46 GMT+0200/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>提取fastq文件中的序列信息</title>
    <link href="http://yoursite.com/2020/03/30/Mon%20Mar%2030%202020%2020:36:45%20GMT+0200/"/>
    <id>http://yoursite.com/2020/03/30/Mon Mar 30 2020 20:36:45 GMT+0200/</id>
    <published>2020-03-30T18:36:45.000Z</published>
    <updated>2020-03-30T18:51:58.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>提取fastq文件中的序列信息，并输出为一行</p><p><img src="/2020/03/30/Mon Mar 30 2020 20:36:45 GMT+0200/fg1.png" style="zoom:50%;"></p><h3 id="方法一：paste-cut实现"><a href="#方法一：paste-cut实现" class="headerlink" title="方法一：paste + cut实现"></a>方法一：paste + cut实现</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head CH2500.fq | paste - - - - | cut -f 2 | paste -d '' -s</span><br></pre></td></tr></table></figure><p><img src="/2020/03/30/Mon Mar 30 2020 20:36:45 GMT+0200/fg2.png" alt></p><ul><li><code>paste - - - -</code> 将fastq的每4行转化为列，并以空格分割；<code></code>cut -f 2<code>提取第二列信息，即之前的第二行信息，序列信息，然后再利用paste ，</code>-d<code>指定分隔符为无，</code>-s` 合并为一行信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;提取fastq文件中的序列信息，并输出为一行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/30/Mon Mar 30 2020 20
      
    
    </summary>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>肿瘤免疫治疗研究的平台——TIDE</title>
    <link href="http://yoursite.com/2020/02/29/Sat%20Feb%2029%202020%2022:44:18%20GMT+0100/"/>
    <id>http://yoursite.com/2020/02/29/Sat Feb 29 2020 22:44:18 GMT+0100/</id>
    <published>2020-02-29T21:44:18.000Z</published>
    <updated>2020-02-29T21:46:36.840Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p>利用公共数据模拟免疫疗法的效应和耐药性</p><p><strong>文章信息</strong></p><p>题目：Large-scale public data reuse to model immunotherapy response and resistance                           </p><p>杂志：Genome Medicine</p><p>时间：26 February,2020</p><p>链接: <a href="https://doi.org/10.1186/s13073-020-0721-z" target="_blank" rel="noopener">https://doi.org/10.1186/s13073-020-0721-z</a>                       </p><p><strong>figure</strong></p><p><img src="/2020/02/29/Sat Feb 29 2020 22:44:18 GMT+0100/resize,w_1500-20200229224559989.png" alt="image.png"></p><a id="more"></a><p><strong>文章介绍：</strong></p><p>这是刘小乐老师实验室开发的一个网络平台——TIDE(<a href="http://tide.dfci.harvard.edu/login/" target="_blank" rel="noopener">http://tide.dfci.harvard.edu/login/</a>) （很好奇为什么命名为TIDE，而且网站图标也是来自<a href="https://mall.jd.com/index-1000001829.html" target="_blank" rel="noopener">汰渍</a>），用于推断调节肿瘤免疫的基因的功能，并评估预测免疫检查点抑制剂(immune checkpoint blockade,ICB)临床反应的标记物。</p><p>他们共处理了12项公开发表的ICB临床研究中的998例肿瘤的组学数据，以及8个已发表的用于鉴定参与调节淋巴细胞介导的肿瘤杀伤和免疫治疗的基因CRISPR筛选研究。其中ICB队列的临床数据共有188个肿瘤队列中的33000个样本，这些样本主要来自TCGA,METABRIC和PRECOG数据库，以及实验室内部数据。该网络平台的功能包括3个交互分析模块：将与肿瘤免疫逃逸相关的标记物进行排序，生成假设；然后通过AUC score 和生存曲线对标记物评估；最后根据标记物对患者分类。</p><p>对肿瘤免疫感兴趣的同学可以仔细研究下文章是如何整合公共数据的，以及利用该平台为课题提供一些新思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用公共数据模拟免疫疗法的效应和耐药性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：Large-scale public data reuse to model immunotherapy response and resistance                           &lt;/p&gt;
&lt;p&gt;杂志：Genome Medicine&lt;/p&gt;
&lt;p&gt;时间：26 February,2020&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://doi.org/10.1186/s13073-020-0721-z&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://doi.org/10.1186/s13073-020-0721-z&lt;/a&gt;                       &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/29/Sat Feb 29 2020 22:44:18 GMT+0100/resize,w_1500-20200229224559989.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>综述|深度学习框架、应用和发展趋向</title>
    <link href="http://yoursite.com/2020/02/15/Sat%20Feb%2015%202020%2010:13:51%20GMT+0100/"/>
    <id>http://yoursite.com/2020/02/15/Sat Feb 15 2020 10:13:51 GMT+0100/</id>
    <published>2020-02-15T09:13:51.000Z</published>
    <updated>2020-02-20T08:47:44.597Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p>深度学习框架、应用和发展趋向</p><p><strong>文章信息</strong></p><p>题目：A Review of Deep Learning with Special Emphasis on Architectures, Applications and Recent Trends</p><p>杂志：Knowledge-Based Systems</p><p>时间：6 February 2020</p><p>链接: <a href="https://doi.org/10.1016/j.knosys.2020.105596" target="_blank" rel="noopener">https://doi.org/10.1016/j.knosys.2020.105596</a></p><p><strong>figure</strong></p><p><img src="/2020/02/15/Sat Feb 15 2020 10:13:51 GMT+0100/fig1.png" alt></p><p><strong>文章介绍：</strong></p><p>随着公众对深度学习有效性的认识不断提高，利用深度学习解决不同实际问题的愿望也在增加。但是，即使是对专业人员来说，接触该领域所产生的迅速增长的知识体系也是令人望而生畏的。从哪里开始？如何确定特定的深度学习模型是否适用于他们的问题？如何训练和部署这样一个网络？</p><p>这篇综述对组成深度学习的一些关键的多层人工神经网络进行了概述；同时讨论了一些使用多代理方法的自动架构优化方案；此外，由于保证系统的正常运行时间对许多计算机应用来说是至关重要的，我们将介绍如何使用神经网络进行故障检测和随后的缓解；并且对深度学习在不不同领域的应用进行了讨论。</p><p>这篇综述可以作为想涉及深度学习领域的初学者的一篇参考读物。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深度学习框架、应用和发展趋向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：A Review of Deep Learning with Special Emphasis on Ar
      
    
    </summary>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>细菌生物信息资源数据库——PATRIC</title>
    <link href="http://yoursite.com/2020/02/08/Sat%20Feb%2008%202020%2019:22:12%20GMT+0100/"/>
    <id>http://yoursite.com/2020/02/08/Sat Feb 08 2020 19:22:12 GMT+0100/</id>
    <published>2020-02-08T18:22:12.000Z</published>
    <updated>2020-02-12T08:48:20.302Z</updated>
    
    <content type="html"><![CDATA[<p>PATRIC <a href="https://www.patricbrc.org/" target="_blank" rel="noopener">https://www.patricbrc.org/</a> ：即病理系统资源整合中心，提供了集成的数据资源和分析工具，以支持有关细菌感染性疾病的生物医学研究。</p><blockquote><p><strong>PATRIC</strong>, the Pathosystems Resource Integration Center, provides integrated data and analysis tools to support biomedical research on bacterial infectious diseases.</p></blockquote><p>下面是该网站主页，主要包含3个模块：</p><ul><li>第一个是搜索模块，可以对细菌、古细菌、噬菌体以及真核宿主进行搜索，数据包括基因组、基因、转录组实验、分类学等信息；</li><li>第二个是数据分析模块，可以进行基因组组装、注释、RNA-seq、代谢组的分析等</li><li>第三个是多组学数据资源，如AMR数据，基因组数据，蛋白质家族，特殊基因等数据资源</li></ul><a id="more"></a><p><img src="/2020/02/08/Sat Feb 08 2020 19:22:12 GMT+0100/fig1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PATRIC &lt;a href=&quot;https://www.patricbrc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.patricbrc.org/&lt;/a&gt; ：即病理系统资源整合中心，提供了集成的数据资源和分析工具，以支持有关细菌感染性疾病的生物医学研究。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;PATRIC&lt;/strong&gt;, the Pathosystems Resource Integration Center, provides integrated data and analysis tools to support biomedical research on bacterial infectious diseases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是该网站主页，主要包含3个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个是搜索模块，可以对细菌、古细菌、噬菌体以及真核宿主进行搜索，数据包括基因组、基因、转录组实验、分类学等信息；&lt;/li&gt;
&lt;li&gt;第二个是数据分析模块，可以进行基因组组装、注释、RNA-seq、代谢组的分析等&lt;/li&gt;
&lt;li&gt;第三个是多组学数据资源，如AMR数据，基因组数据，蛋白质家族，特殊基因等数据资源&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
      <category term="AMR" scheme="http://yoursite.com/tags/AMR/"/>
    
  </entry>
  
  <entry>
    <title>类器官和ATAC-seq技术结合研究人前脑发育图谱</title>
    <link href="http://yoursite.com/2020/02/08/Sat%20Feb%2008%202020%2019:12:18%20GMT+0100/"/>
    <id>http://yoursite.com/2020/02/08/Sat Feb 08 2020 19:12:18 GMT+0100/</id>
    <published>2020-02-08T18:12:18.000Z</published>
    <updated>2020-02-08T18:18:31.860Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p>人类前脑发育的染色质可及性动态图谱</p><p><strong>文章信息</strong></p><p>题目：Chromatin accessibility dynamics in a model of human forebrain development                                </p><p>杂志：Science</p><p>时间：24 January 2020</p><p>链接: <a href="http://dx.doi" target="_blank" rel="noopener">http://dx.doi</a>. org/10.1126/ science.aay1645</p><p><strong>figure</strong></p><p><img src="/2020/02/08/Sat Feb 08 2020 19:12:18 GMT+0100/fig1.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章介绍：</strong></p><p>人类前脑发育在很大程度上是细胞水平研究、直接功能研究或操纵所无法达到的。缺乏初级脑组织样本，特别是在后期，以及传统的体外细胞模型的局限性，阻碍了对健康和疾病状态下皮质激素生成的详细机制性理解。而文中利用干细胞3D定向分化技术形成背侧和腹侧的前脑干细胞作为原始研究组织，更加接近体内真实的发育情况，然后利用ATAC-seq和RNA测序技术绘制了体外20多个月的神经元和胶质细胞系的发育图谱。并对增强子和基因的相互作用，以及每个发育时期特异的转录调控因子进行了探究。然后他们利用这个资源绘制了与精神分裂症和自闭症谱系失调相关的基因和遗传变异图，以区分染色质可及性模式，从而揭示细胞类型和易感期。最后，他们鉴定到在皮质神经发生过程中染色质重构的现象，在此期间四分之一的调节区域是活跃的，并推测这些转录因子可能驱动这些发育变化。</p><p><img src="/2020/02/08/Sat Feb 08 2020 19:12:18 GMT+0100/fig2.png" style="zoom:50%;"></p><p>关于脑神经发育过程中染色质可及性图谱的文章已有人发表过，这篇文章仍然能发到Science上，借助了一项重要的实验技术——对干细胞进行重编程然后进行3D培养形成人脑的类器官。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人类前脑发育的染色质可及性动态图谱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：Chromatin accessibility dynamics in a model of human forebrain development                                &lt;/p&gt;
&lt;p&gt;杂志：Science&lt;/p&gt;
&lt;p&gt;时间：24 January 2020&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;http://dx.doi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dx.doi&lt;/a&gt;. org/10.1126/ science.aay1645&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/08/Sat Feb 08 2020 19:12:18 GMT+0100/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ATACseq" scheme="http://yoursite.com/tags/ATACseq/"/>
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>构建基因调控网络的新算法</title>
    <link href="http://yoursite.com/2020/01/04/Sat%20Jan%2004%202020%2016:25:08%20GMT+0100/"/>
    <id>http://yoursite.com/2020/01/04/Sat Jan 04 2020 16:25:08 GMT+0100/</id>
    <published>2020-01-04T15:25:08.000Z</published>
    <updated>2020-01-04T08:34:51.028Z</updated>
    
    <content type="html"><![CDATA[<p>基因表达数据被广泛用于推测基因调控网络（Gene regulatory networks, GRNs）。单细胞RNAseq数据包含单个细胞的表达信息，非常有利于调控机制的研究。但是，目前从大量的表达数据中明确转录调控机制仍然面临挑战，而且，重构后的调控网络可能无法捕获主要的调控规则。</p><p>这篇文章提出了一个新的方法——TENET：从scRNAseq数据中通过<strong>传递熵（transfer entropy, TE)</strong> 计算基因间的因果关系，从而构建GRNs<strong>。</strong>他们的结果发现已知的靶基因具有显著高的TE值，且TE值越高的基因受各种干扰的影响越大。与其他方法相比，他们的结果表明TENET优于其他GRN预测算法。还有一个重要的性能是该方法可以鉴定关键的调控因子。将TENET应用于胚胎干细胞向神经细胞分化过程中的scRNAseq数据，他们发现Nme2是2i条件下特异性干细胞自我更新的关键因子。</p><p><img src="/2020/01/04/Sat Jan 04 2020 16:25:08 GMT+0100/fig-.png"></p><a id="more"></a><p><strong>一句话评价</strong></p><p>构建基因调控网络的新算法</p><p><strong>文章信息</strong></p><p>题目：Gene network reconstruction using single cell transcriptomic</p><p>data reveals key factors for embryonic stem cell differentiation</p><p>杂志：bioRxiv</p><p>时间：Dec. 21, 2019</p><p>链接: <a href="https://www.biorxiv.org/content/10.1101/2019.12.20.884163v1" target="_blank" rel="noopener">https://www.biorxiv.org/content/10.1101/2019.12.20.884163v1</a></p><blockquote><p>有点遗憾，如果半年前自己上点心的话，可能就能深入这个方向的研究了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基因表达数据被广泛用于推测基因调控网络（Gene regulatory networks, GRNs）。单细胞RNAseq数据包含单个细胞的表达信息，非常有利于调控机制的研究。但是，目前从大量的表达数据中明确转录调控机制仍然面临挑战，而且，重构后的调控网络可能无法捕获主要的调控规则。&lt;/p&gt;
&lt;p&gt;这篇文章提出了一个新的方法——TENET：从scRNAseq数据中通过&lt;strong&gt;传递熵（transfer entropy, TE)&lt;/strong&gt; 计算基因间的因果关系，从而构建GRNs&lt;strong&gt;。&lt;/strong&gt;他们的结果发现已知的靶基因具有显著高的TE值，且TE值越高的基因受各种干扰的影响越大。与其他方法相比，他们的结果表明TENET优于其他GRN预测算法。还有一个重要的性能是该方法可以鉴定关键的调控因子。将TENET应用于胚胎干细胞向神经细胞分化过程中的scRNAseq数据，他们发现Nme2是2i条件下特异性干细胞自我更新的关键因子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/01/04/Sat Jan 04 2020 16:25:08 GMT+0100/fig-.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="literature" scheme="http://yoursite.com/categories/literature/"/>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="scRNA-seq" scheme="http://yoursite.com/tags/scRNA-seq/"/>
    
      <category term="regulation network" scheme="http://yoursite.com/tags/regulation-network/"/>
    
  </entry>
  
  <entry>
    <title>利用多组学数据预测药物组合的驱动网络标记物</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:47:14%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:47:14 GMT+0100/</id>
    <published>2019-12-29T09:47:14.000Z</published>
    <updated>2019-12-29T04:35:29.280Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>药物组合不仅可能同时抑制多种肿瘤的驱动信号通路，而且有可能减少药物抵抗性。这篇文章介绍了一个利用多组学数据开发的工具——<strong>DrugComboExplorer</strong>，鉴定药物组合的驱动信号通路，并预测药物组合的协同作用。</p><p>该工具通过处理来自单个癌症患者的DNA测序、基因拷贝数、DNA甲基化和RNA序列数据，使用整合的算法（包括bootstrap aggregating-based Markov random field，WGCNA,监督调控网络学习）流程产生驱动信号网络。</p><p>DrugComboExplorer is available at <a href="https://github.com/Roosevelt-" target="_blank" rel="noopener">https://github.com/Roosevelt-</a> PKU/drugcombinationprediction.</p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:47:14 GMT+0100/fig.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章信息</strong></p><p>题目：Driver network as a biomarker: systematic integration and network modeling of multi-omics data to derive driver signaling pathways for drug combination prediction</p><p>杂志：Bioinformatics,</p><p>时间：15 February 2019</p><p>链接: doi: 10.1093/bioinformatics/btz109</p><blockquote><p>每日文献摘要：第27篇  2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;药物组合不仅可能同时抑制多种肿瘤的驱动信号通路，而且有可能减少药物抵抗性。这篇文章介绍了一个利用多组学数据开发的工具——&lt;strong&gt;DrugComboExplorer&lt;/strong&gt;，鉴定药物组合的驱动信号通路，并预测药物组合的协同作用。&lt;/p&gt;
&lt;p&gt;该工具通过处理来自单个癌症患者的DNA测序、基因拷贝数、DNA甲基化和RNA序列数据，使用整合的算法（包括bootstrap aggregating-based Markov random field，WGCNA,监督调控网络学习）流程产生驱动信号网络。&lt;/p&gt;
&lt;p&gt;DrugComboExplorer is available at &lt;a href=&quot;https://github.com/Roosevelt-&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Roosevelt-&lt;/a&gt; PKU/drugcombinationprediction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:47:14 GMT+0100/fig.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>利用全基因组组织表达谱预测疾病相关lncRNA</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:43:16%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:43:16 GMT+0100/</id>
    <published>2019-12-29T09:43:16.000Z</published>
    <updated>2019-12-29T04:36:08.110Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>基于机器学习的方法——<strong>DislncRF</strong>，根据组织表达谱从全基因组范围预测疾病相关的lncRNA。<strong>DislncRF</strong>是基于随机森林模型训练已知的与疾病相关的蛋白编码基因（protein-coding genes ，PCGs），从而提取疾病与表达谱的一般模式，然后应用到lncRNA与疾病的关联中，</p><p>代码：<a href="https://github.com/xypan1232/DislncRF" target="_blank" rel="noopener">https://github.com/xypan1232/DislncRF</a></p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:43:16 GMT+0100/fig1.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章信息</strong></p><p>题目：Inferring disease-associated long non-coding RNAs using genome-wide tissue expression profiles</p><p>杂志：Bioinformatics</p><p>时间：2018</p><p>链接: doi.10.1093/bioinformatics/xxxxxx</p><p><strong>碎碎念</strong></p><p>利用蛋白编码基因与疾病的模式训练模型，然后预测lncRNA与疾病的关联，这样选训练集可靠吗？</p><blockquote><p>每日文献摘要：第28篇  2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于机器学习的方法——&lt;strong&gt;DislncRF&lt;/strong&gt;，根据组织表达谱从全基因组范围预测疾病相关的lncRNA。&lt;strong&gt;DislncRF&lt;/strong&gt;是基于随机森林模型训练已知的与疾病相关的蛋白编码基因（protein-coding genes ，PCGs），从而提取疾病与表达谱的一般模式，然后应用到lncRNA与疾病的关联中，&lt;/p&gt;
&lt;p&gt;代码：&lt;a href=&quot;https://github.com/xypan1232/DislncRF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xypan1232/DislncRF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:43:16 GMT+0100/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="lncRNA" scheme="http://yoursite.com/tags/lncRNA/"/>
    
  </entry>
  
  <entry>
    <title>利用多组学数据重构调控网络</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:36:25%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:36:25 GMT+0100/</id>
    <published>2019-12-29T09:36:25.000Z</published>
    <updated>2019-12-29T04:36:03.911Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>随着测序技术的发展，生命组学数据和医学数据爆炸式增长，单一组学指标并不能够充分反映疾病或正常的生命发育机制，结合多组学从不同层面揭示调控机制将有助于我们更精确的认识生命过程和疾病病因。这篇综述使用<strong>state-of-the-art techniques</strong>方法概括了调控网络重构的方法，为挖掘多组学数据（基因组、转录组、蛋白质组等）和其他生物数据背后的意义提供了参考。</p><p><strong>figure</strong></p><p>数据整合策略：</p><p><img src="/2019/12/29/Sun Dec 29 2019 10:36:25 GMT+0100/fig2.png" style="zoom:50%;"></p><a id="more"></a><p>数据整合方法：</p><p><img src="/2019/12/29/Sun Dec 29 2019 10:36:25 GMT+0100/fig1.png" style="zoom:50%;"></p><p><strong>文章信息</strong></p><p>题目：Integrative approaches to reconstruct regulatory networks from multi-omics T data: A review of state-of-the-art methods</p><p>杂志：Computational Biology and Chemistry</p><p>时间：August, 2019</p><p>链接: <a href="https://doi.org/10.1016/j.compbiolchem.2019.107120" target="_blank" rel="noopener">https://doi.org/10.1016/j.compbiolchem.2019.107120</a></p><p>每日文献摘要：第29篇  2019年12月29日 周日</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着测序技术的发展，生命组学数据和医学数据爆炸式增长，单一组学指标并不能够充分反映疾病或正常的生命发育机制，结合多组学从不同层面揭示调控机制将有助于我们更精确的认识生命过程和疾病病因。这篇综述使用&lt;strong&gt;state-of-the-art techniques&lt;/strong&gt;方法概括了调控网络重构的方法，为挖掘多组学数据（基因组、转录组、蛋白质组等）和其他生物数据背后的意义提供了参考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据整合策略：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:36:25 GMT+0100/fig2.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="multi-omics" scheme="http://yoursite.com/tags/multi-omics/"/>
    
      <category term="regulation network" scheme="http://yoursite.com/tags/regulation-network/"/>
    
  </entry>
  
  <entry>
    <title>深度学习在遗传变异和表观调控中的应用</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:34:47%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:34:47 GMT+0100/</id>
    <published>2019-12-29T09:34:47.000Z</published>
    <updated>2019-12-29T04:50:32.539Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>利用深度学习卷积神经网络的方法，以表观数据和基因组遗产数据作为参考，训练模型，预测遗传变异的影响。</p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:34:47 GMT+0100/fig1.png" style="zoom:33%;"></p><a id="more"></a><p><strong>文章信息</strong></p><p>题目：Functional interpretation of genetic variants using deep learning predicts impact on chromatin accessibility and histone modification</p><p>杂志：<em>Nucleic Acids Research</em></p><p>时间：2019</p><p>链接: <em>doi: 10.1093/nar/gkz808</em></p><p>每日文献摘要：第30篇  2019年12月30日 周日</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用深度学习卷积神经网络的方法，以表观数据和基因组遗产数据作为参考，训练模型，预测遗传变异的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:34:47 GMT+0100/fig1.png&quot; style=&quot;zoom:33%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>非编码RNA数据库</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:32:10%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:32:10 GMT+0100/</id>
    <published>2019-12-29T09:32:10.000Z</published>
    <updated>2019-12-29T05:11:28.504Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p><strong>RNAcentral</strong>是一个综合的非编码RNA数据库，包括大量物种所有类型的<strong>非编码RNA序列信息</strong>，同时整合了28个数据库，可以搜索比较不同数据库ncRNA序列信息，也可以与数据库比对检索序列与ncRNA序列的相似性，也可以通过Genome browser可视化ncRNA在基因组区域的注释信息，所有数据可以下载。</p><p>数据库网址：<strong><a href="https://rnacentral.org" target="_blank" rel="noopener">https://rnacentral.org</a></strong></p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:32:10 GMT+0100/fig1.png" style="zoom:50%;"></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:32:10 GMT+0100/fig2.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章信息</strong></p><p>题目：RNAcentral: a hub of information for non-coding RNA sequences</p><p>杂志：<em>Nucleic Acids Research,</em></p><p>时间：November, 2019</p><p>链接: <em>doi: 10.1093/nar/gky1034</em></p><blockquote><p>每日文献摘要：第31篇  2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RNAcentral&lt;/strong&gt;是一个综合的非编码RNA数据库，包括大量物种所有类型的&lt;strong&gt;非编码RNA序列信息&lt;/strong&gt;，同时整合了28个数据库，可以搜索比较不同数据库ncRNA序列信息，也可以与数据库比对检索序列与ncRNA序列的相似性，也可以通过Genome browser可视化ncRNA在基因组区域的注释信息，所有数据可以下载。&lt;/p&gt;
&lt;p&gt;数据库网址：&lt;strong&gt;&lt;a href=&quot;https://rnacentral.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://rnacentral.org&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:32:10 GMT+0100/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:32:10 GMT+0100/fig2.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="lncRNA" scheme="http://yoursite.com/tags/lncRNA/"/>
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>单细胞分析相关R包汇总</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:31:22%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:31:22 GMT+0100/</id>
    <published>2019-12-29T09:31:22.000Z</published>
    <updated>2019-12-29T05:59:46.400Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>Bioconductor是一个针对生物数据分析的以R语言开发的开源软件库，从2001年项目开始至今，提供了很多优秀的分析流程，如bulk-RNA-seq的分析流程，文档非常详细。如今出手整理了单细胞分析的流程，包括软件安装、数据导入、单细胞数据储存、格式转换为下游分析的数据、下游分析、可视化等，非常详细，另外他们提供了<strong>在线book：<a href="https://osca.bioconductor" target="_blank" rel="noopener">https://osca.bioconductor</a> </strong>.，想上手学习单细胞分析的以本书作为一个入门是一个不错的选择。</p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:31:22 GMT+0100/fig1.png" style="zoom:50%;"></p><a id="more"></a><p><strong>文章信息</strong></p><p>题目：Orchestrating single-cell analysis with Bioconductor</p><p>杂志：Nature Methods</p><p>时间：02, December, 2019</p><p>链接: <a href="https://www.nature.com/articles/s41592-019-0654-x" target="_blank" rel="noopener">https://www.nature.com/articles/s41592-019-0654-x</a></p><blockquote><p>每日文献摘要：第32篇  2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bioconductor是一个针对生物数据分析的以R语言开发的开源软件库，从2001年项目开始至今，提供了很多优秀的分析流程，如bulk-RNA-seq的分析流程，文档非常详细。如今出手整理了单细胞分析的流程，包括软件安装、数据导入、单细胞数据储存、格式转换为下游分析的数据、下游分析、可视化等，非常详细，另外他们提供了&lt;strong&gt;在线book：&lt;a href=&quot;https://osca.bioconductor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://osca.bioconductor&lt;/a&gt; &lt;/strong&gt;.，想上手学习单细胞分析的以本书作为一个入门是一个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:31:22 GMT+0100/fig1.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="http://yoursite.com/tags/software/"/>
    
      <category term="single cell" scheme="http://yoursite.com/tags/single-cell/"/>
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>深度学习在药物基因组学中的学习和数据资源</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:28:18%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:28:18 GMT+0100/</id>
    <published>2019-12-29T09:28:18.000Z</published>
    <updated>2019-12-29T06:14:27.131Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章介绍：</strong></p><p>这篇综述介绍了深度学习的基本模型和典型模型架构，同时总结了深度学习（DL）在肿瘤和肿瘤亚型鉴定的应用（即病人的诊断和分诊治疗），在药物对个体的效应和协同作用的预测，以及在机制、治疗研究中药物的发现和定位的应用。他们整合了基因组学数据和药物基因组数据资源，如 TCGA, ICGC等药物数据库，以及P a DEL药物数据库等。系统地描绘了深度学习在肿瘤药物基因组学中应用。</p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:28:18 GMT+0100/fig2.png" style="zoom:50%;"></p><a id="more"></a><p><img src="/2019/12/29/Sun Dec 29 2019 10:28:18 GMT+0100/fig1.png" style="zoom:50%;"></p><p><strong>文章信息</strong></p><p>题目：Deep learning of pharmacogenomics resources: moving towards precision oncology</p><p>杂志：Briefings in Bioinformatics</p><p>时间：2019</p><p>链接: doi: 10.1093/bib/bbz144</p><blockquote><p>每日文献摘要：第33篇  2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇综述介绍了深度学习的基本模型和典型模型架构，同时总结了深度学习（DL）在肿瘤和肿瘤亚型鉴定的应用（即病人的诊断和分诊治疗），在药物对个体的效应和协同作用的预测，以及在机制、治疗研究中药物的发现和定位的应用。他们整合了基因组学数据和药物基因组数据资源，如 TCGA, ICGC等药物数据库，以及P a DEL药物数据库等。系统地描绘了深度学习在肿瘤药物基因组学中应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:28:18 GMT+0100/fig2.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>新的降维可视化方法</title>
    <link href="http://yoursite.com/2019/12/29/Sun%20Dec%2029%202019%2010:04:27%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/29/Sun Dec 29 2019 10:04:27 GMT+0100/</id>
    <published>2019-12-29T09:04:27.000Z</published>
    <updated>2019-12-29T02:14:52.306Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p><strong>新的高维数据结构和模式的可视化方法——PHATE</strong></p><p><strong>文章信息</strong></p><p>题目：Visualizing structure and transitions in high-dimensional biological data</p><p>杂志：Nature biotechnology</p><p>时间：3 December,2019</p><p>链接: <a href="https://www.nature.com/articles/s41587-019-0336-3" target="_blank" rel="noopener">https://www.nature.com/articles/s41587-019-0336-3</a></p><p><strong>figure</strong></p><p><img src="/2019/12/29/Sun Dec 29 2019 10:04:27 GMT+0100/0-20191228212010064.png" style="zoom: 33%;"></p><a id="more"></a><p><strong>文章介绍：</strong></p><p>这篇文章提出常见的降维方法如PCA, t-SNE等方法存在对噪音敏感（PCA, Isomap)、扰乱数据结构(t-SNE)、没有为二维可视化优化（PCA &amp; diffusion maps)，计算资源消耗大、依赖于先验知识等不足，他们提出了一种利用数据点之间的信息几何距离(information-geometric distance)同时捕捉局部和全局的非线性结构的可视化方法——PHATE(potential of heat diffusion for affinity-based transition embedding)。与其他常见的降维方法相比，该方法能够更好的保持数据中的一系列结构模式，包括连续的发展进程、分支结构、簇的结构（clusters）。此外，他们定义了一个叫DEMaP的度量，可以更好的去噪。他们在实际数据中验证了该方法的有效性，并且可用于质谱数据、单细胞数据、Hi-C数据、肠道微生物等多种数据类型。</p><blockquote><p>每日文献摘要：第26篇 2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新的高维数据结构和模式的可视化方法——PHATE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：Visualizing structure and transitions in high-dimensional biological data&lt;/p&gt;
&lt;p&gt;杂志：Nature biotechnology&lt;/p&gt;
&lt;p&gt;时间：3 December,2019&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://www.nature.com/articles/s41587-019-0336-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nature.com/articles/s41587-019-0336-3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/29/Sun Dec 29 2019 10:04:27 GMT+0100/0-20191228212010064.png&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="http://yoursite.com/tags/software/"/>
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="降维" scheme="http://yoursite.com/tags/%E9%99%8D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>单细胞RNA-seq分析流程的系统评估</title>
    <link href="http://yoursite.com/2019/12/28/Sat%20Dec%2028%202019%2019:46:35%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/28/Sat Dec 28 2019 19:46:35 GMT+0100/</id>
    <published>2019-12-28T18:46:35.000Z</published>
    <updated>2019-12-29T02:14:24.507Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话评价</strong></p><p>scRNA-seq分析流程大比拼</p><p><strong>文章信息</strong></p><p>题目：A systematic evaluation of single cell RNA-seq analysis pipelines</p><p>杂志：Nature Communication</p><p>时间：11, October, 2019</p><p>链接: <a href="https://doi.org/10.1038/s41467-019-12266-7" target="_blank" rel="noopener">https://doi.org/10.1038/s41467-019-12266-7</a></p><p><strong>figure</strong></p><p><img src="/2019/12/28/Sat Dec 28 2019 19:46:35 GMT+0100/fig1.png" style="zoom: 33%;"></p><a id="more"></a><p><strong>文章介绍：</strong></p><p>单细胞RNA-seq是单细胞领域较为成熟的技术，相关的实验方法和计算方法也不断被开发，面临着越来越多的方法和工具，如何选择合适的最佳流程呢？这篇文章从单细胞建库方法，比对、imputation、标准化和差异方法共评估约3000个组合流程。评价结果可以作为选择最佳分析流程的一个参考，不过所谓的最佳流程并不是以一概全指某个特定流程，而是要根据实际研究目的，选择合适的实验方法和分析方法。</p><p>另外还可以参考前不久发表的单细胞RNA-seq最佳分析流程：Current best practices in single‐cell RNA‐seq analysis: a tutorial (<a href="https://doi.org/10.15252/msb.20188746" target="_blank" rel="noopener">https://doi.org/10.15252/msb.20188746</a>)</p><blockquote><p>每日文献摘要：第25篇 2019年12月29日 周日</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一句话评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;scRNA-seq分析流程大比拼&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目：A systematic evaluation of single cell RNA-seq analysis pipelines&lt;/p&gt;
&lt;p&gt;杂志：Nature Communication&lt;/p&gt;
&lt;p&gt;时间：11, October, 2019&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://doi.org/10.1038/s41467-019-12266-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://doi.org/10.1038/s41467-019-12266-7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/28/Sat Dec 28 2019 19:46:35 GMT+0100/fig1.png&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="single cell" scheme="http://yoursite.com/tags/single-cell/"/>
    
      <category term="文献摘要" scheme="http://yoursite.com/tags/%E6%96%87%E7%8C%AE%E6%91%98%E8%A6%81/"/>
    
      <category term="scRNA-seq" scheme="http://yoursite.com/tags/scRNA-seq/"/>
    
  </entry>
  
  <entry>
    <title>基于R语言绘制坐标轴截断图</title>
    <link href="http://yoursite.com/2019/12/16/Mon%20Dec%2016%202019%2020:18:11%20GMT+0100/"/>
    <id>http://yoursite.com/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/</id>
    <published>2019-12-16T19:18:11.000Z</published>
    <updated>2019-12-19T07:17:49.183Z</updated>
    
    <content type="html"><![CDATA[<p>画图时经常遇到不同组的数据大小相差很大，大数据就会掩盖小数据的变化规律，这时候可以对Y轴进行截断，从而可以在不同层面（大数据和小数据层面）全面反映数据变化情况，如下图所示。</p><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig0.png" alt></p><p>搜索截断图绘制的方法，有根据Excel绘制的，但是感觉操作繁琐；这里根据网上资料总结基于R的3种方法：</p><ul><li>分割+组合法，如基于ggplot2, 利用<code>coord_cartesian()</code>将整个图形分割成多个图片,再用grid 包组合分割结果</li><li>plotrix R包</li><li>基本绘图函数+plotrix R包</li></ul><a id="more"></a><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(name=c(<span class="string">"AY"</span>,<span class="string">"BY"</span>,<span class="string">"CY"</span>,<span class="string">"DY"</span>,<span class="string">"EY"</span>,<span class="string">"FY"</span>,<span class="string">"GY"</span>),Money=c(<span class="number">1510</span>,<span class="number">1230</span>,<span class="number">995</span>,<span class="number">48</span>,<span class="number">35</span>,<span class="number">28</span>,<span class="number">10</span>))</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载 R 包</span></span><br><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="comment"># ggplot画图</span></span><br><span class="line">p0 &lt;- ggplot(df, aes(name,Money,fill = name)) +</span><br><span class="line">  geom_col(position = position_dodge(width = <span class="number">0.8</span>),color=<span class="string">"black"</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>, y = <span class="literal">NULL</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">"Accent"</span>)+</span><br><span class="line">  <span class="comment">#scale_x_discrete(expand = c(0, 0)) +</span></span><br><span class="line">  scale_y_continuous(breaks = seq(<span class="number">0</span>, <span class="number">1600</span>, <span class="number">400</span>), limits = c(<span class="number">0</span>, <span class="number">1600</span>), expand = c(<span class="number">0</span>,<span class="number">0</span>)) +</span><br><span class="line">  theme(axis.text.x = element_text(angle = <span class="number">45</span>, hjust = <span class="number">1</span>), legend.title = element_blank())</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig1.png" alt="fig1" style="zoom:25%;"></p><h3 id="方法一：分割-组合法"><a href="#方法一：分割-组合法" class="headerlink" title="方法一：分割+组合法"></a>方法一：分割+组合法</h3><p>这种方法的思路是分别绘制不同层级大小的图形，然后组合图形。如可一用ggplot2中的<code>coord_cartesian()</code>函数分割，<code>ylim</code>指定y轴的区间范围。</p><blockquote><p>参考：<a href="http://blog.sciencenet.cn/blog-3406804-1156908.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-3406804-1156908.html</a></p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 小数据层级</span></span><br><span class="line">p1 &lt;- p0 + coord_cartesian(ylim = c(<span class="number">0</span>, <span class="number">50</span>)) + </span><br><span class="line">  theme_classic()+</span><br><span class="line">  theme(legend.position=<span class="string">"none"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">### 大数据层级</span></span><br><span class="line"><span class="comment"># 不显示X轴坐标和文本标记</span></span><br><span class="line">p2 &lt;-p0 + coord_cartesian(ylim = c(<span class="number">700</span>, <span class="number">1600</span>)) + </span><br><span class="line">  theme_classic() +</span><br><span class="line">  theme(axis.line.x = element_line(colour=<span class="string">"white"</span>),</span><br><span class="line">        axis.text.x = element_blank(), axis.ticks.x = element_blank(), </span><br><span class="line">        legend.position = c(<span class="number">0.85</span>, <span class="number">0.6</span>))</span><br></pre></td></tr></table></figure><p><code>P1</code></p><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig2.png" style="zoom: 25%;"></p><p><code>p2</code></p><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig3.png" style="zoom:25%;"></p><p>grid组合图形, <code>grid.newpage()</code>新建画布, <code>viewport()</code>命令将画板分割为不同的区域。</p><blockquote><p>x和y分别用于指定所放置子图在画板中的坐标，坐标取值范围为0~1，并使用just给定坐标起始位置；width和height用于指定所放置子图在画板中的高度和宽度。</p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(grid)</span><br><span class="line"></span><br><span class="line">grid.newpage() <span class="comment">#新建画布</span></span><br><span class="line">plot_site1 &lt;- viewport(x = <span class="number">0.008</span>, y = <span class="number">0</span>, width = <span class="number">0.994</span>, height = <span class="number">0.4</span>, just = c(<span class="string">'left'</span>, <span class="string">'bottom'</span>))</span><br><span class="line">plot_site2 &lt;- viewport(x = <span class="number">0.008</span>, y = <span class="number">0.4</span>, width = <span class="number">1</span>, height = <span class="number">0.5</span>, just = c(<span class="string">'left'</span>, <span class="string">'bottom'</span>))</span><br><span class="line"><span class="comment">#plot_site3 &lt;- viewport(x = 0, y = 0.7, width = 1, height = 0.3, just = c('left', 'bottom'))</span></span><br><span class="line">print(p1, vp = plot_site1)</span><br><span class="line">print(p2, vp = plot_site2)</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig4.png" style="zoom:50%;"></p><p>这种方法可以得到一个草图，图片对齐等细节调节需要多次尝试，或者可以导出在AI中修改。</p><h3 id="方法二：plotrix-R包"><a href="#方法二：plotrix-R包" class="headerlink" title="方法二：plotrix R包"></a>方法二：plotrix R包</h3><p>plotrix R中包含<code>gap.plot()，gap.barplot() 和 gapboxplot()函数</code>, 可以分别画出坐标轴截断的散点图、柱状图和箱线图。主要参数包括<code>y    ：要截断的数值向量; gap：截断的区间</code>.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 用法如下</span></span><br><span class="line"> gap.barplot(y,gap,xaxlab,xtics,yaxlab,ytics,xlim=<span class="literal">NA</span>,ylim=<span class="literal">NA</span>,xlab=<span class="literal">NULL</span>,</span><br><span class="line">  ylab=<span class="literal">NULL</span>,horiz=<span class="literal">FALSE</span>,col,<span class="keyword">...</span>)</span><br><span class="line"><span class="comment">### Arguments</span></span><br><span class="line">y：要截断的数值向量</span><br><span class="line">gap：截断的区间</span><br><span class="line"></span><br><span class="line">xaxlab：labels <span class="keyword">for</span> the x axis ticks</span><br><span class="line">xtics：position of the x axis ticks</span><br><span class="line">yaxlab：labels <span class="keyword">for</span> the y axis ticks</span><br><span class="line">ytics：position of the y axis ticks</span><br><span class="line">xlim：Optional x limits <span class="keyword">for</span> the plot</span><br><span class="line">ylim：optional y limits <span class="keyword">for</span> the plot</span><br><span class="line">xlab：label <span class="keyword">for</span> the x axis</span><br><span class="line">ylab：label <span class="keyword">for</span> the y axis</span><br><span class="line">horiz：whether to have vertical or horizontal bars</span><br><span class="line">col：color(s) <span class="keyword">in</span> which to plot the values</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="http://www.bioon.com.cn/protocol/showarticle.asp?newsid=66061" target="_blank" rel="noopener">http://www.bioon.com.cn/protocol/showarticle.asp?newsid=66061</a></p></blockquote><p>相同的数据，画图如下</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install.packages ("plotrix")</span></span><br><span class="line"><span class="keyword">library</span> (plotrix)</span><br><span class="line"></span><br><span class="line">gap.barplot(df$Money,gap=c(<span class="number">50</span>,<span class="number">740</span>),xaxlab=df$name,ytics=c(<span class="number">50</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">1000</span>,<span class="number">1100</span>,<span class="number">1200</span>,<span class="number">1300</span>,<span class="number">1400</span>,<span class="number">1500</span>,<span class="number">1600</span>),</span><br><span class="line">            col=rainbow(<span class="number">7</span>),xlim = c(<span class="number">0</span>,<span class="number">8</span>),width=<span class="number">0.06</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig5.png" style="zoom:50%;"></p><p>接着使用<code>axis breaks()</code>函数去除中间的两道横线，并添加截断的标记，如<code>//</code>或<code>z</code>。</p><ul><li><code>Axis</code>:1,2,3,4分别代表下、左、上、右方位的坐标轴，即打算截取的坐标轴</li><li><code>breakppos</code>：截断的位置，即截断符号添加的位置</li><li><code>style</code>: gap,slash和z字形</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axis.break(<span class="number">2</span>,<span class="number">50</span>,breakcol=<span class="string">"snow"</span>,style=<span class="string">"gap"</span>) <span class="comment">##去掉中间的那两道横线；</span></span><br><span class="line">axis.break(<span class="number">2</span>,<span class="number">50</span>*(<span class="number">1</span>+<span class="number">0.02</span>),breakcol=<span class="string">"black"</span>,style=<span class="string">"slash"</span>)<span class="comment">##在左侧Y轴把gap位置换成slash；</span></span><br><span class="line"><span class="comment">#axis.break(4,50*(1+0.02),breakcol="black",style="slash")##在右侧Y轴把gap位置换成slash；</span></span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig6.png" style="zoom:50%;"></p><p>这种方法是基于base plot绘图的，但是base plot的许多绘图参数与gap.barplot（）并不兼容，如<code>space和width参数</code>设置离坐标轴距离和bar的宽度。</p><h3 id="方法三：基本绘图函数-plotrix-R包"><a href="#方法三：基本绘图函数-plotrix-R包" class="headerlink" title="方法三：基本绘图函数+plotrix R包"></a>方法三：基本绘图函数+plotrix R包</h3><blockquote><p>参考：<a href="https://blog.csdn.net/u014801157/article/details/24372371" target="_blank" rel="noopener">https://blog.csdn.net/u014801157/article/details/24372371</a></p></blockquote><p>作者ZGUANG@LZU自己编写的函数，可以手动设置断点，也可以由函数自动计算。断点位置的符号表示提供了平行线和zigzag两种，并且可设置背景颜色、大小、线型、平行线旋转角度等。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#' 使用R基本绘图函数绘制y轴不连续的柱形图</span></span><br><span class="line"><span class="comment">#'</span></span><br><span class="line"><span class="comment">#' 绘制y轴不连续的柱形图，具有误差线添加功能。断点位置通过btm和top参数设置，如果不设置，函数可自动计算合适的断点位置。</span></span><br><span class="line"><span class="comment">#' @title gap.barplot function</span></span><br><span class="line"><span class="comment">#' @param df 长格式的data.frame，即数据框中每一列为一组绘图数据。</span></span><br><span class="line"><span class="comment">#' @param y.cols 用做柱形图y值的数据列（序号或名称），一列为一组。</span></span><br><span class="line"><span class="comment">#' @param sd.cols 与y值列顺序对应的误差值的数据列（序号或名称）。</span></span><br><span class="line"><span class="comment">#' @param btm 低位断点。如果btm和top均不设置，程序将自动计算和设置断点位置。</span></span><br><span class="line"><span class="comment">#' @param top 高位断点。</span></span><br><span class="line"><span class="comment">#' @param min.range 自动计算断点的阈值：最大值与最小值的最小比值</span></span><br><span class="line"><span class="comment">#' @param max.fold 自动计算断点时最大值与下方数据最大值的最大倍数比</span></span><br><span class="line"><span class="comment">#' @param ratio 断裂后上部与下部y轴长度的比例。</span></span><br><span class="line"><span class="comment">#' @param gap.width y轴断裂位置的相对物理宽度（非坐标轴实际刻度）</span></span><br><span class="line"><span class="comment">#' @param brk.type 断点类型，可设为normal或zigzag</span></span><br><span class="line"><span class="comment">#' @param brk.bg 断点处的背景颜色</span></span><br><span class="line"><span class="comment">#' @param brk.srt 断点标记线旋转角度</span></span><br><span class="line"><span class="comment">#' @param brk.size 断点标记线的大小（长度）</span></span><br><span class="line"><span class="comment">#' @param brk.col 断点标记线的颜色</span></span><br><span class="line"><span class="comment">#' @param brk.lwd 断点标记线的线宽</span></span><br><span class="line"><span class="comment">#' @param cex.error 误差线相对长度，默认为1</span></span><br><span class="line"><span class="comment">#' @param ... 其他传递给R基本绘图函数barplot的参数</span></span><br><span class="line"><span class="comment">#' @return 返回barplot的原始返回值，即柱形图的x坐标</span></span><br><span class="line"><span class="comment">#' @examples</span></span><br><span class="line"><span class="comment">#' datax &lt;- na.omit(airquality)[,1:4]</span></span><br><span class="line"><span class="comment">#' cols &lt;- cm.colors(ncol(datax))</span></span><br><span class="line"><span class="comment">#' layout(matrix(1:6, ncol=2))</span></span><br><span class="line"><span class="comment">#' set.seed(0)</span></span><br><span class="line"><span class="comment">#' for (ndx in 1:6)&#123;</span></span><br><span class="line"><span class="comment">#'     dt &lt;- datax[sample(rownames(datax), 10), ]</span></span><br><span class="line"><span class="comment">#'     par(mar=c(0.5,2,0.5,0.5))</span></span><br><span class="line"><span class="comment">#'     brkt &lt;- sample(c('normal', 'zigzag'), 1)</span></span><br><span class="line"><span class="comment">#'     gap.barplot(dt, col=cols, brk.type=brkt, max.fold=5, ratio=2)</span></span><br><span class="line"><span class="comment">#' &#125;</span></span><br><span class="line"><span class="comment">#' @author ZG Zhao</span></span><br><span class="line"><span class="comment">#' @export</span></span><br><span class="line">gap.barplot &lt;- <span class="keyword">function</span>(df, y.cols = <span class="number">1</span>:ncol(df), sd.cols = <span class="literal">NULL</span>, btm = <span class="literal">NULL</span>,</span><br><span class="line">                        top = <span class="literal">NULL</span>, min.range = <span class="number">10</span>, max.fold = <span class="number">5</span>, ratio = <span class="number">1</span>, gap.width = <span class="number">1</span>, brk.type = <span class="string">"normal"</span>,</span><br><span class="line">                        brk.bg = <span class="string">"white"</span>, brk.srt = <span class="number">135</span>, brk.size = <span class="number">1</span>, brk.col = <span class="string">"black"</span>, brk.lwd = <span class="number">1</span>,</span><br><span class="line">                        cex.error = <span class="number">1</span>, <span class="keyword">...</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (missing(df))</span><br><span class="line">    <span class="keyword">stop</span>(<span class="string">"No data provided."</span>)</span><br><span class="line">  <span class="keyword">if</span> (is.numeric(y.cols))</span><br><span class="line">    ycol &lt;- y.cols <span class="keyword">else</span> ycol &lt;- colnames(df) == y.cols</span><br><span class="line">    <span class="keyword">if</span> (!is.null(sd.cols))</span><br><span class="line">      <span class="keyword">if</span> (is.numeric(sd.cols))</span><br><span class="line">        scol &lt;- sd.cols <span class="keyword">else</span> scol &lt;- colnames(df) == sd.cols</span><br><span class="line">        <span class="comment">## Arrange data</span></span><br><span class="line">        opts &lt;- options()</span><br><span class="line">        options(warn = -<span class="number">1</span>)</span><br><span class="line">        y &lt;- t(df[, ycol])</span><br><span class="line">        colnames(y) &lt;- <span class="literal">NULL</span></span><br><span class="line">        <span class="keyword">if</span> (missing(sd.cols))</span><br><span class="line">          sdx &lt;- <span class="number">0</span> <span class="keyword">else</span> sdx &lt;- t(df[, scol])</span><br><span class="line">        sdu &lt;- y + sdx</span><br><span class="line">        sdd &lt;- y - sdx</span><br><span class="line">        ylim &lt;- c(<span class="number">0</span>, max(sdu) * <span class="number">1.05</span>)</span><br><span class="line">        <span class="comment">## 如果没有设置btm或top，自动计算</span></span><br><span class="line">        <span class="keyword">if</span> (is.null(btm) | is.null(top)) &#123;</span><br><span class="line">          autox &lt;- .auto.breaks(dt = sdu, min.range = min.range, max.fold = max.fold)</span><br><span class="line">          <span class="keyword">if</span> (autox$flag) &#123;</span><br><span class="line">            btm &lt;- autox$btm</span><br><span class="line">            top &lt;- autox$top</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xx &lt;- barplot(y, beside = <span class="literal">TRUE</span>, ylim = ylim, <span class="keyword">...</span>)</span><br><span class="line">            <span class="keyword">if</span> (!missing(sd.cols))</span><br><span class="line">              errorbar(xx, y, sdu - y, horiz = <span class="literal">FALSE</span>, cex = cex.error)</span><br><span class="line">            box()</span><br><span class="line">            <span class="keyword">return</span>(invisible(xx))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">## Set up virtual y limits</span></span><br><span class="line">        halflen &lt;- btm - ylim[<span class="number">1</span>]</span><br><span class="line">        xlen &lt;- halflen * <span class="number">0.1</span> * gap.width</span><br><span class="line">        v_tps1 &lt;- btm + xlen  <span class="comment"># virtual top positions</span></span><br><span class="line">        v_tps2 &lt;- v_tps1 + halflen * ratio</span><br><span class="line">        v_ylim &lt;- c(ylim[<span class="number">1</span>], v_tps2)</span><br><span class="line">        r_tps1 &lt;- top  <span class="comment"># real top positions</span></span><br><span class="line">        r_tps2 &lt;- ylim[<span class="number">2</span>]</span><br><span class="line">        <span class="comment">## Rescale data</span></span><br><span class="line">        lmx &lt;- summary(lm(c(v_tps1, v_tps2) ~ c(r_tps1, r_tps2)))</span><br><span class="line">        lmx &lt;- lmx$coefficients</span><br><span class="line">        sel1 &lt;- y &gt; top</span><br><span class="line">        sel2 &lt;- y &gt;= btm &amp; y &lt;= top</span><br><span class="line">        y[sel1] &lt;- y[sel1] * lmx[<span class="number">2</span>] + lmx[<span class="number">1</span>]</span><br><span class="line">        y[sel2] &lt;- btm + xlen/<span class="number">2</span></span><br><span class="line">        sel1 &lt;- sdd &gt; top</span><br><span class="line">        sel2 &lt;- sdd &gt;= btm &amp; sdd &lt;= top</span><br><span class="line">        sdd[sel1] &lt;- sdd[sel1] * lmx[<span class="number">2</span>] + lmx[<span class="number">1</span>]</span><br><span class="line">        sdd[sel2] &lt;- btm + xlen/<span class="number">2</span></span><br><span class="line">        sel1 &lt;- sdu &gt; top</span><br><span class="line">        sel2 &lt;- sdu &gt;= btm &amp; sdu &lt;= top</span><br><span class="line">        sdu[sel1] &lt;- sdu[sel1] * lmx[<span class="number">2</span>] + lmx[<span class="number">1</span>]</span><br><span class="line">        sdu[sel2] &lt;- btm + xlen/<span class="number">2</span></span><br><span class="line">        <span class="comment">## bar plot</span></span><br><span class="line">        xx &lt;- barplot(y, beside = <span class="literal">TRUE</span>, ylim = v_ylim, axes = <span class="literal">FALSE</span>, names.arg = <span class="literal">NULL</span>,</span><br><span class="line">                      <span class="keyword">...</span>)</span><br><span class="line">        <span class="comment">## error bars</span></span><br><span class="line">        <span class="keyword">if</span> (!missing(sd.cols))</span><br><span class="line">          errorbar(xx, y, sdu - y, horiz = <span class="literal">FALSE</span>, cex = cex.error)</span><br><span class="line">        <span class="comment">## Real ticks and labels</span></span><br><span class="line">        brks1 &lt;- pretty(seq(<span class="number">0</span>, btm, length = <span class="number">10</span>), n = <span class="number">4</span>)</span><br><span class="line">        brks1 &lt;- brks1[brks1 &gt;= <span class="number">0</span> &amp; brks1 &lt; btm]</span><br><span class="line">        brks2 &lt;- pretty(seq(top, r_tps2, length = <span class="number">10</span>), n = <span class="number">4</span>)</span><br><span class="line">        brks2 &lt;- brks2[brks2 &gt; top &amp; brks2 &lt;= r_tps2]</span><br><span class="line">        labx &lt;- c(brks1, brks2)</span><br><span class="line">        <span class="comment">## Virtual ticks</span></span><br><span class="line">        brks &lt;- c(brks1, brks2 * lmx[<span class="number">2</span>] + lmx[<span class="number">1</span>])</span><br><span class="line">        axis(<span class="number">2</span>, at = brks, labels = labx)</span><br><span class="line">        box()</span><br><span class="line">        <span class="comment">## break marks</span></span><br><span class="line">        pos &lt;- par(<span class="string">"usr"</span>)</span><br><span class="line">        xyratio &lt;- (pos[<span class="number">2</span>] - pos[<span class="number">1</span>])/(pos[<span class="number">4</span>] - pos[<span class="number">3</span>])</span><br><span class="line">        xlen &lt;- (pos[<span class="number">2</span>] - pos[<span class="number">1</span>])/<span class="number">50</span> * brk.size</span><br><span class="line">        px1 &lt;- pos[<span class="number">1</span>] - xlen</span><br><span class="line">        px2 &lt;- pos[<span class="number">1</span>] + xlen</span><br><span class="line">        px3 &lt;- pos[<span class="number">2</span>] - xlen</span><br><span class="line">        px4 &lt;- pos[<span class="number">2</span>] + xlen</span><br><span class="line">        py1 &lt;- btm</span><br><span class="line">        py2 &lt;- v_tps1</span><br><span class="line">        rect(px1, py1, px4, py2, col = brk.bg, xpd = <span class="literal">TRUE</span>, border = brk.bg)</span><br><span class="line">        x1 &lt;- c(px1, px1, px3, px3)</span><br><span class="line">        x2 &lt;- c(px2, px2, px4, px4)</span><br><span class="line">        y1 &lt;- c(py1, py2, py1, py2)</span><br><span class="line">        y2 &lt;- c(py1, py2, py1, py2)</span><br><span class="line">        px &lt;- .xy.adjust(x1, x2, y1, y2, xlen, xyratio, angle = brk.srt * pi/<span class="number">90</span>)</span><br><span class="line">        <span class="keyword">if</span> (brk.type == <span class="string">"zigzag"</span>) &#123;</span><br><span class="line">          x1 &lt;- c(x1, px1, px3)</span><br><span class="line">          x2 &lt;- c(x2, px2, px4)</span><br><span class="line">          <span class="keyword">if</span> (brk.srt &gt; <span class="number">90</span>) &#123;</span><br><span class="line">            y1 &lt;- c(y1, py2, py2)</span><br><span class="line">            y2 &lt;- c(y2, py1, py1)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y1 &lt;- c(y1, py1, py1)</span><br><span class="line">            y2 &lt;- c(y2, py2, py2)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (brk.type == <span class="string">"zigzag"</span>) &#123;</span><br><span class="line">          px$x1 &lt;- c(pos[<span class="number">1</span>], px2, px1, pos[<span class="number">2</span>], px4, px3)</span><br><span class="line">          px$x2 &lt;- c(px2, px1, pos[<span class="number">1</span>], px4, px3, pos[<span class="number">2</span>])</span><br><span class="line">          mm &lt;- (v_tps1 - btm)/<span class="number">3</span></span><br><span class="line">          px$y1 &lt;- rep(c(v_tps1, v_tps1 - mm, v_tps1 - <span class="number">2</span> * mm), <span class="number">2</span>)</span><br><span class="line">          px$y2 &lt;- rep(c(v_tps1 - mm, v_tps1 - <span class="number">2</span> * mm, btm), <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        par(xpd = <span class="literal">TRUE</span>)</span><br><span class="line">        segments(px$x1, px$y1, px$x2, px$y2, lty = <span class="number">1</span>, col = brk.col, lwd = brk.lwd)</span><br><span class="line">        options(opts)</span><br><span class="line">        par(xpd = <span class="literal">FALSE</span>)</span><br><span class="line">        invisible(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 绘制误差线的函数</span></span><br><span class="line">errorbar &lt;- <span class="keyword">function</span>(x, y, sd.lwr, sd.upr, horiz = <span class="literal">FALSE</span>, cex = <span class="number">1</span>, <span class="keyword">...</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (missing(sd.lwr) &amp; missing(sd.upr))</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">if</span> (missing(sd.upr))</span><br><span class="line">    sd.upr &lt;- sd.lwr</span><br><span class="line">  <span class="keyword">if</span> (missing(sd.lwr))</span><br><span class="line">    sd.lwr &lt;- sd.upr</span><br><span class="line">  <span class="keyword">if</span> (!horiz) &#123;</span><br><span class="line">    arrows(x, y, y1 = y - sd.lwr, length = <span class="number">0.1</span> * cex, angle = <span class="number">90</span>, <span class="keyword">...</span>)</span><br><span class="line">    arrows(x, y, y1 = y + sd.upr, length = <span class="number">0.1</span> * cex, angle = <span class="number">90</span>, <span class="keyword">...</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arrows(y, x, x1 = y - sd.lwr, length = <span class="number">0.1</span> * cex, angle = <span class="number">90</span>, <span class="keyword">...</span>)</span><br><span class="line">    arrows(y, x, x1 = y + sd.upr, length = <span class="number">0.1</span> * cex, angle = <span class="number">90</span>, <span class="keyword">...</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.xy.adjust &lt;- <span class="keyword">function</span>(x1, x2, y1, y2, xlen, xyratio, angle) &#123;</span><br><span class="line">  xx1 &lt;- x1 - xlen * cos(angle)</span><br><span class="line">  yy1 &lt;- y1 + xlen * sin(angle)/xyratio</span><br><span class="line">  xx2 &lt;- x2 + xlen * cos(angle)</span><br><span class="line">  yy2 &lt;- y2 - xlen * sin(angle)/xyratio</span><br><span class="line">  <span class="keyword">return</span>(list(x1 = xx1, x2 = xx2, y1 = yy1, y2 = yy2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## 自动计算断点位置的函数</span></span><br><span class="line">.auto.breaks &lt;- <span class="keyword">function</span>(dt, min.range, max.fold) &#123;</span><br><span class="line">  datax &lt;- sort(as.vector(dt))</span><br><span class="line">  flags &lt;- <span class="literal">FALSE</span></span><br><span class="line">  btm &lt;- top &lt;- <span class="literal">NULL</span></span><br><span class="line">  <span class="keyword">if</span> (max(datax)/min(datax) &lt; min.range)</span><br><span class="line">    <span class="keyword">return</span>(list(flag = flags, btm = btm, top = top))</span><br><span class="line">  m &lt;- max(datax)</span><br><span class="line">  btm &lt;- datax[<span class="number">2</span>]</span><br><span class="line">  i &lt;- <span class="number">3</span></span><br><span class="line">  <span class="keyword">while</span> (m/datax[i] &gt; max.fold) &#123;</span><br><span class="line">    btm &lt;- datax[i]</span><br><span class="line">    flags &lt;- <span class="literal">TRUE</span></span><br><span class="line">    i &lt;- i + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags) &#123;</span><br><span class="line">    btm &lt;- btm + <span class="number">0.05</span> * btm</span><br><span class="line">    x &lt;- <span class="number">2</span></span><br><span class="line">    top &lt;- datax[i] * (x - <span class="number">1</span>)/x</span><br><span class="line">    <span class="keyword">while</span> (top &lt; btm) &#123;</span><br><span class="line">      x &lt;- x + <span class="number">1</span></span><br><span class="line">      top &lt;- datax[i] * (x - <span class="number">1</span>)/x</span><br><span class="line">      <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        flags &lt;- <span class="literal">FALSE</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(list(flag = flags, btm = btm, top = top))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例数据-1"><a href="#示例数据-1" class="headerlink" title="示例数据"></a>示例数据</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">datax &lt;- na.omit(airquality)[, <span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">cols &lt;- terrain.colors(ncol(datax) - <span class="number">1</span>)</span><br><span class="line">layout(matrix(<span class="number">1</span>:<span class="number">4</span>, ncol = <span class="number">2</span>))</span><br><span class="line">set.seed(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (ndx <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span>) &#123;</span><br><span class="line">  dt &lt;- datax[sample(rownames(datax), <span class="number">10</span>), ]</span><br><span class="line">  dt &lt;- cbind(dt, dt[, -<span class="number">1</span>] * <span class="number">0.1</span>)</span><br><span class="line">  par(mar = c(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">  brkt &lt;- sample(c(<span class="string">"normal"</span>, <span class="string">"zigzag"</span>), <span class="number">1</span>)</span><br><span class="line">  gap.barplot(dt, y.cols = <span class="number">2</span>:<span class="number">4</span>, sd.cols = <span class="number">5</span>:<span class="number">7</span>, col = cols, brk.type = brkt,</span><br><span class="line">              brk.size = <span class="number">0.6</span>, brk.lwd = <span class="number">2</span>, max.fold = <span class="number">5</span>, ratio = <span class="number">2</span>, cex.error = <span class="number">0.3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig7.png" style="zoom:50%;"></p><h4 id="实际数据"><a href="#实际数据" class="headerlink" title="实际数据"></a>实际数据</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gap.barplot(df, y.cols = <span class="number">2</span>, brk.type = <span class="string">"normal"</span>,col = rainbow(<span class="number">7</span>),</span><br><span class="line">            brk.size = <span class="number">0.6</span>, brk.lwd = <span class="number">2</span>, max.fold = <span class="number">5</span>, ratio = <span class="number">2</span>, cex.error = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig8.png" style="zoom:50%;"></p><p>第3种方法可以直接计算截断值，另外可以添加error bar, 可以修改的细节处更多，而且包装成函数，整个分析时间也加快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;画图时经常遇到不同组的数据大小相差很大，大数据就会掩盖小数据的变化规律，这时候可以对Y轴进行截断，从而可以在不同层面（大数据和小数据层面）全面反映数据变化情况，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/16/Mon Dec 16 2019 20:18:11 GMT+0100/fig0.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;搜索截断图绘制的方法，有根据Excel绘制的，但是感觉操作繁琐；这里根据网上资料总结基于R的3种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分割+组合法，如基于ggplot2, 利用&lt;code&gt;coord_cartesian()&lt;/code&gt;将整个图形分割成多个图片,再用grid 包组合分割结果&lt;/li&gt;
&lt;li&gt;plotrix R包&lt;/li&gt;
&lt;li&gt;基本绘图函数+plotrix R包&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
      <category term="visualization" scheme="http://yoursite.com/tags/visualization/"/>
    
  </entry>
  
</feed>
